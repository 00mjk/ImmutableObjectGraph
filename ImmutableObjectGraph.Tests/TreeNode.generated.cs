// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace ImmutableObjectGraph.Tests {
	using System.Diagnostics;
	using System.Linq;
	using ImmutableObjectGraph;
	
	public partial class TreeNode : System.Collections.Generic.IEnumerable<TreeNode>, IRecursiveParentWithOrderedChildren, IRecursiveParent<TreeNode>, IRecursiveType, IRecursiveParentWithLookupTable<TreeNode>, IRecursiveParentWithChildReplacement<TreeNode> {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly TreeNode DefaultInstance = GetDefaultTemplate();
		
		/// <summary>The last identity assigned to a created instance.</summary>
		private static int lastIdentityProduced;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.String caption;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.String filePath;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Boolean visible;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Collections.Immutable.ImmutableHashSet<System.String> attributes;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Collections.Immutable.ImmutableList<TreeNode> children;
	
		private readonly System.UInt32 identity;
	
		/// <summary>Initializes a new instance of the TreeNode class.</summary>
		protected TreeNode(
			System.UInt32 identity,
			System.String caption,
			System.String filePath,
			System.Boolean visible,
			System.Collections.Immutable.ImmutableHashSet<System.String> attributes,
			System.Collections.Immutable.ImmutableList<TreeNode> children,
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<TreeNode, System.UInt32>>> lookupTable = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<TreeNode, System.UInt32>>>),
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
		{
			this.identity = identity;
			this.caption = caption;
			this.filePath = filePath;
			this.visible = visible;
			this.attributes = attributes;
			this.children = children;
			if (!skipValidation.Value) {
				this.Validate();
			}
			var lookupTableInitResult = RecursiveTypeExtensions.LookupTable<TreeNode, TreeNode>.Initialize(this, lookupTable);
			this.lookupTable = lookupTableInitResult.LookupTable;
			this.inefficiencyLoad = lookupTableInitResult.InefficiencyLoad;
		}
	
		public static TreeNode Create(
			ImmutableObjectGraph.Optional<System.String> caption = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.String> filePath = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.Boolean> visible = default(ImmutableObjectGraph.Optional<System.Boolean>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<TreeNode>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<TreeNode>>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				caption: Optional.For(caption.GetValueOrDefault(DefaultInstance.Caption)),
				filePath: Optional.For(filePath.GetValueOrDefault(DefaultInstance.FilePath)),
				visible: Optional.For(visible.GetValueOrDefault(DefaultInstance.Visible)),
				attributes: Optional.For(attributes.GetValueOrDefault(DefaultInstance.Attributes)),
				children: Optional.For(children.GetValueOrDefault(DefaultInstance.Children)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public System.String Caption {
			get { return this.caption; }
		}
	
		public System.String FilePath {
			get { return this.filePath; }
		}
	
		public System.Boolean Visible {
			get { return this.visible; }
		}
	
		public System.Collections.Immutable.ImmutableHashSet<System.String> Attributes {
			get { return this.attributes; }
		}
	
		public System.Collections.Immutable.ImmutableList<TreeNode> Children {
			get { return this.children; }
		}
		
		/// <summary>Replaces the elements of the Attributes collection with the specified collection.</summary>
		public TreeNode WithAttributes(params System.String[] values) {
			return this.With(attributes: this.Attributes.ResetContents(values));
		}
		
		/// <summary>Replaces the elements of the Attributes collection with the specified collection.</summary>
		public TreeNode WithAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			return this.With(attributes: this.Attributes.ResetContents(values));
		}
		
		/// <summary>Adds the specified elements from the Attributes collection.</summary>
		public TreeNode AddAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			return this.With(attributes: this.Attributes.AddRange(values));
		}
		
		/// <summary>Adds the specified elements from the Attributes collection.</summary>
		public TreeNode AddAttributes(params System.String[] values) {
			return this.With(attributes: this.Attributes.AddRange(values));
		}
		
		/// <summary>Adds the specified element from the Attributes collection.</summary>
		public TreeNode AddAttribute(System.String value) {
			return this.With(attributes: this.Attributes.Add(value));
		}
		
		/// <summary>Removes the specified elements from the Attributes collection.</summary>
		public TreeNode RemoveAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			return this.With(attributes: this.Attributes.RemoveRange(values));
		}
		
		/// <summary>Removes the specified elements from the Attributes collection.</summary>
		public TreeNode RemoveAttributes(params System.String[] values) {
			return this.With(attributes: this.Attributes.RemoveRange(values));
		}
		
		/// <summary>Removes the specified element from the Attributes collection.</summary>
		public TreeNode RemoveAttribute(System.String value) {
			return this.With(attributes: this.Attributes.Remove(value));
		}
		
		/// <summary>Clears all elements from the Attributes collection.</summary>
		public TreeNode RemoveAttributes() {
			return this.With(attributes: this.Attributes.Clear());
		}
		
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public TreeNode WithChildren(params TreeNode[] values) {
			return this.With(children: this.Children.ResetContents(values));
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public TreeNode WithChildren(System.Collections.Generic.IEnumerable<TreeNode> values) {
			return this.With(children: this.Children.ResetContents(values));
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public TreeNode AddChildren(System.Collections.Generic.IEnumerable<TreeNode> values) {
			return this.With(children: this.Children.AddRange(values));
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public TreeNode AddChildren(params TreeNode[] values) {
			return this.With(children: this.Children.AddRange(values));
		}
		
		/// <summary>Adds the specified element from the Children collection.</summary>
		public TreeNode AddChild(TreeNode value) {
			return this.With(children: this.Children.Add(value));
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public TreeNode RemoveChildren(System.Collections.Generic.IEnumerable<TreeNode> values) {
			return this.With(children: this.Children.RemoveRange(values.Select(v => this.SyncImmediateChildToCurrentVersion(v))));
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public TreeNode RemoveChildren(params TreeNode[] values) {
			return this.With(children: this.Children.RemoveRange(values.Select(v => this.SyncImmediateChildToCurrentVersion(v))));
		}
		
		/// <summary>Removes the specified element from the Children collection.</summary>
		public TreeNode RemoveChild(TreeNode value) {
			return this.With(children: this.Children.Remove(this.SyncImmediateChildToCurrentVersion(value)));
		}
		
		/// <summary>Clears all elements from the Children collection.</summary>
		public TreeNode RemoveChildren() {
			return this.With(children: this.Children.Clear());
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public TreeNode With(
			ImmutableObjectGraph.Optional<System.String> caption = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.String> filePath = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.Boolean> visible = default(ImmutableObjectGraph.Optional<System.Boolean>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<TreeNode>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<TreeNode>>)) {
			return (TreeNode)this.WithCore(
				caption: caption,
				filePath: filePath,
				visible: visible,
				attributes: attributes,
				children: children);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected virtual TreeNode WithCore(
			ImmutableObjectGraph.Optional<System.String> caption = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.String> filePath = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.Boolean> visible = default(ImmutableObjectGraph.Optional<System.Boolean>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<TreeNode>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<TreeNode>>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.UInt32>);
			return this.WithFactory(
				caption: Optional.For(caption.GetValueOrDefault(this.Caption)),
				filePath: Optional.For(filePath.GetValueOrDefault(this.FilePath)),
				visible: Optional.For(visible.GetValueOrDefault(this.Visible)),
				attributes: Optional.For(attributes.GetValueOrDefault(this.Attributes)),
				children: Optional.For(children.GetValueOrDefault(this.Children)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private TreeNode WithFactory(
			ImmutableObjectGraph.Optional<System.String> caption = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.String> filePath = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.Boolean> visible = default(ImmutableObjectGraph.Optional<System.Boolean>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<TreeNode>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<TreeNode>>),
			ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(caption.IsDefined && caption.Value != this.Caption) || 
				(filePath.IsDefined && filePath.Value != this.FilePath) || 
				(visible.IsDefined && visible.Value != this.Visible) || 
				(attributes.IsDefined && attributes.Value != this.Attributes) || 
				(children.IsDefined && children.Value != this.Children)) {
				var lookupTable = children.IsDefined && children.Value != this.Children ? default(Optional<System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<TreeNode, System.UInt32>>>) : Optional.For(this.lookupTable);
				return new TreeNode(
					identity: identity.GetValueOrDefault(this.Identity),
					caption: caption.GetValueOrDefault(this.Caption),
					filePath: filePath.GetValueOrDefault(this.FilePath),
					visible: visible.GetValueOrDefault(this.Visible),
					attributes: attributes.GetValueOrDefault(this.Attributes),
					children: children.GetValueOrDefault(this.Children),
					lookupTable: lookupTable);
			} else {
				return this;
			}
		}
	
		protected internal uint Identity {
			get { return (uint)this.identity; }
		}
	
		/// <summary>Returns a unique identity that may be assigned to a newly created instance.</summary>
		protected static System.UInt32 NewIdentity() {
			return (System.UInt32)System.Threading.Interlocked.Increment(ref lastIdentityProduced);
		}
	
		public System.Collections.Generic.IEnumerator<TreeNode> GetEnumerator() {
			return this.children.GetEnumerator();
		}
	
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
			return this.children.GetEnumerator();
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated TreeNode whose fields are initialized with default values.</summary>
		private static TreeNode GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new TreeNode(
				default(System.UInt32),
				template.Caption,
				template.FilePath,
				template.Visible,
				template.Attributes,
				template.Children,
				skipValidation: true);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.String Caption { get; set; }
	
			internal System.String FilePath { get; set; }
	
			internal System.Boolean Visible { get; set; }
	
			internal System.Collections.Immutable.ImmutableHashSet<System.String> Attributes { get; set; }
	
			internal System.Collections.Immutable.ImmutableList<TreeNode> Children { get; set; }
		}
		
		protected TreeNode SyncImmediateChildToCurrentVersion(TreeNode child) {
			TreeNode currentValue;
			if (!this.TryFindImmediateChild(child.Identity, out currentValue)) {
				throw new System.ArgumentException();
			}
		
			return currentValue;
		}
		
		public TreeNode AddDescendent(TreeNode value, TreeNode parent) {
			var spine = this.GetSpine(parent);
			var newParent = parent.AddChildren(value);
			var newSpine = System.Collections.Immutable.ImmutableStack.Create(value, newParent);
			return (TreeNode)this.ReplaceDescendent(spine, newSpine, spineIncludesDeletedElement: false).Peek();
		}
		
		public TreeNode RemoveDescendent(TreeNode value) {
			var spine = this.GetSpine(value);
			var spineList = spine.ToList();
			var parent = (TreeNode)spineList[spineList.Count - 2];
			var newParent = parent.RemoveChildren(spineList[spineList.Count - 1]);
		
			var newSpine = System.Collections.Immutable.ImmutableStack.Create((TreeNode)newParent);
			return (TreeNode)this.ReplaceDescendent(spine, newSpine, spineIncludesDeletedElement: true).Peek();
		}
		
		/// <summary>Replaces one node with a modified version of itself (same identity) among this node's descendents</summary>
		public TreeNode ReplaceDescendent(TreeNode updatedNode) {
			var spine = this.GetSpine(updatedNode.Identity);
		
			if (spine.IsEmpty) {
				// The descendent was not found.
				throw new System.ArgumentException("Old value not found");
			}
		
			return (TreeNode)this.ReplaceDescendent(spine, System.Collections.Immutable.ImmutableStack.Create(updatedNode), spineIncludesDeletedElement: false).Peek();
		}
		
		/// <summary>Replaces one node with another node that may have a different identity.</summary>
		public TreeNode ReplaceDescendent(TreeNode current, TreeNode replacement) {
			var spine = this.GetSpine(current);
		
			if (spine.IsEmpty) {
				// The descendent was not found.
				throw new System.ArgumentException("Old value not found");
			}
		
			return (TreeNode)this.ReplaceDescendent(spine, System.Collections.Immutable.ImmutableStack.Create(replacement), spineIncludesDeletedElement: false).Peek();
		}
		
		
		private System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<TreeNode, System.UInt32>> lookupTable;
		
		private uint inefficiencyLoad;
		
		private System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<TreeNode, System.UInt32>> LookupTable {
			get {
				if (this.lookupTable == RecursiveTypeExtensions.LookupTable<TreeNode, TreeNode>.LazySentinel) {
					this.lookupTable = RecursiveTypeExtensions.LookupTable<TreeNode, TreeNode>.CreateLookupTable(this);
				}
		
				return this.lookupTable;
			}
		}
		
		uint IRecursiveParentWithLookupTable<TreeNode>.InefficiencyLoad {
			get { return this.inefficiencyLoad; }
		}
		
		System.Collections.Generic.IReadOnlyCollection<TreeNode> IRecursiveParentWithLookupTable<TreeNode>.Children {
			get { return this.Children; }
		}
		
		System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<TreeNode, System.UInt32>> IRecursiveParentWithLookupTable<TreeNode>.LookupTable {
			get { return this.LookupTable; }
		}
		
		public System.Collections.Immutable.ImmutableStack<TreeNode> GetSpine(TreeNode descendent) {
			return this.GetSpine<TreeNode, TreeNode>(descendent);
		}
		
		public System.Collections.Immutable.ImmutableStack<TreeNode> GetSpine(System.UInt32 identity) {
			return this.GetSpine<TreeNode, TreeNode>(identity);
		}
		
		public TreeNode Find(System.UInt32 identity)
		{
			return this.Find<TreeNode, TreeNode>(identity);
		}
		
		public TreeNode GetParent(TreeNode descendent) {
			return this.GetParent<TreeNode, TreeNode>(descendent);
		}
		
		public ParentedRecursiveType<TreeNode, TreeNode> GetParentedNode(System.UInt32 identity) {
			return this.GetParentedNode<TreeNode, TreeNode>(identity);
		}
		
		IRecursiveParent<TreeNode> IRecursiveParentWithChildReplacement<TreeNode>.ReplaceChild(System.Collections.Immutable.ImmutableStack<TreeNode> oldSpine, System.Collections.Immutable.ImmutableStack<TreeNode> newSpine) {
			var newChildren = this.Children.Replace(oldSpine.Peek(), newSpine.Peek());
			var newSelf = this.WithChildren(newChildren);
		
			var lookupTableLazySentinel = RecursiveTypeExtensions.LookupTable<TreeNode, TreeNode>.LazySentinel;
			if (newSelf.LookupTable == lookupTableLazySentinel && this.LookupTable != null && this.LookupTable != lookupTableLazySentinel) {
				// Our newly mutated self wants a lookup table. If we already have one we can use it,
				// but it needs to be fixed up given the newly rewritten spine through our descendents.
				newSelf.lookupTable = RecursiveTypeExtensions.LookupTable<TreeNode, TreeNode>.Fixup(this, ImmutableDeque.Create(newSpine), ImmutableDeque.Create(oldSpine));
				RecursiveTypeExtensions.LookupTable<TreeNode, TreeNode>.ValidateInternalIntegrityDebugOnly(newSelf);
			}
		
			return newSelf;
		}
		
	
		System.Collections.Generic.IEnumerable<IRecursiveType> IRecursiveParent.Children {
			get { return this.Children; }
		}
	
		System.Collections.Generic.IEnumerable<TreeNode> IRecursiveParent<TreeNode>.Children {
			get { return this.Children; }
		}
	
		ParentedRecursiveType<IRecursiveParent<IRecursiveType>, IRecursiveType> IRecursiveParent.GetParentedNode(System.UInt32 identity) {
			var parented = this.GetParentedNode(identity);
			return new ParentedRecursiveType<IRecursiveParent<IRecursiveType>, IRecursiveType>(parented.Value, parented.Parent);
		}
		int IRecursiveParentWithOrderedChildren.IndexOf(IRecursiveType value) {
			return this.Children.IndexOf((TreeNode)value);
		}
	
		System.UInt32 IRecursiveType.Identity {
			get { return this.Identity; }
		}
	}
}


