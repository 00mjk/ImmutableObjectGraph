

// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace ImmutableObjectGraph.Tests {
	using System.Diagnostics;
	using System.Linq;
	using ImmutableObjectGraph;
	
	public interface IFileSystemEntry {
		System.String PathSegment { get; }
	}
	
	public abstract partial class FileSystemEntry : IFileSystemEntry {
		
		/// <summary>The last identity assigned to a created instance.</summary>
		private static int lastIdentityProduced;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.String pathSegment;
	
		private readonly System.Int32 identity;
	
		/// <summary>Initializes a new instance of the FileSystemEntry class.</summary>
		protected FileSystemEntry(
			System.Int32 identity,
			System.String pathSegment)
		{
			this.identity = identity;
			this.pathSegment = pathSegment;
		}
	
		public System.String PathSegment {
			get { return this.pathSegment; }
		}
		
		/// <summary>Returns a new instance with the PathSegment property set to the specified value.</summary>
		public FileSystemEntry WithPathSegment(System.String value) {
			if (value == this.PathSegment) {
				return this;
			}
		
			return this.With(pathSegment: Optional.For(value));
		}
		
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public abstract FileSystemEntry With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>));
	
		protected internal System.Int32 Identity {
			get { return this.identity; }
		}
	
		/// <summary>Returns a unique identity that may be assigned to a newly created instance.</summary>
		protected static System.Int32 NewIdentity() {
			return System.Threading.Interlocked.Increment(ref lastIdentityProduced);
		}
		
		public RootedFileSystemEntry WithRoot(FileSystemDirectory root) {
			var spine = root.GetSpine(this);
			if (spine.IsEmpty) {
				throw new System.ArgumentException("Root does not belong to the same tree.");
			}
		
			return new RootedFileSystemEntry(this, root);
		}
		
		public virtual System.Collections.Generic.IReadOnlyList<DiffGram<FileSystemEntry, FileSystemEntryChangedProperties>> ChangesSince(FileSystemEntry priorVersion) {
			if (priorVersion == null) {
				throw new System.ArgumentNullException("priorVersion");
			}
		
			if (priorVersion.Identity != this.Identity) {
				throw new System.ArgumentException("Not another version of the same node.", "priorVersion");
			}
		
			var history = new System.Collections.Generic.List<DiffGram<FileSystemEntry, FileSystemEntryChangedProperties>>();
			var changes = this.DiffProperties(priorVersion);
			if (changes != FileSystemEntryChangedProperties.None) {
				history.Add(DiffGram<FileSystemEntry, FileSystemEntryChangedProperties>.Change(priorVersion, this, changes));
			}
		
			return history;
		}
		
		protected virtual FileSystemEntryChangedProperties DiffProperties(FileSystemEntry other) {
			if (other == null) {
				throw new System.ArgumentNullException("other");
			}
		
			var propertiesChanged = FileSystemEntryChangedProperties.None;
		
			if (!this.GetType().IsEquivalentTo(other.GetType())) {
				propertiesChanged |= FileSystemEntryChangedProperties.Type;
			}
		
			if (this.PathSegment != other.PathSegment) {
				propertiesChanged |= FileSystemEntryChangedProperties.PathSegment;
			}
		
			return propertiesChanged;
		}
		
		public virtual System.Collections.Generic.IEnumerable<FileSystemEntry> GetSelfAndDescendents() {
			yield return this;
		}
		
		public virtual FileSystemFile ToFileSystemFile(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>)) {
			FileSystemFile that = this as FileSystemFile;
			if (that != null && this.GetType().IsEquivalentTo(typeof(FileSystemFile))) {
				if ((!attributes.IsDefined || attributes.Value == that.Attributes)) {
					return that;
				}
			}
		
			return FileSystemFile.Create(
				pathSegment: this.PathSegment,
				attributes: attributes);
		}
		
		public virtual FileSystemDirectory ToFileSystemDirectory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>)) {
			FileSystemDirectory that = this as FileSystemDirectory;
			if (that != null && this.GetType().IsEquivalentTo(typeof(FileSystemDirectory))) {
				if ((!children.IsDefined || children.Value == that.Children)) {
					return that;
				}
			}
		
			return FileSystemDirectory.Create(
				pathSegment: this.PathSegment,
				children: children);
		}
		
		public Builder ToBuilder() {
			return new Builder(this);
		}
		
		public partial class Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private FileSystemEntry immutable;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected System.String pathSegment;
		
			internal Builder(FileSystemEntry immutable) {
				this.immutable = immutable;
		
				this.pathSegment = immutable.PathSegment;
			}
		
			public System.String PathSegment {
				get {
					return this.pathSegment;
				}
		
				set {
					this.pathSegment = value;
				}
			}
		
			public FileSystemEntry ToImmutable() {
				return this.immutable = this.immutable.With(
					ImmutableObjectGraph.Optional.For(this.PathSegment));
			}
		}
	}
	
	public partial struct RootedFileSystemEntry : System.IEquatable<RootedFileSystemEntry> {
		private readonly FileSystemEntry greenNode;
	
		private readonly FileSystemDirectory root;
	
		internal RootedFileSystemEntry(FileSystemEntry fileSystemEntry, FileSystemDirectory root) {
			this.greenNode = fileSystemEntry;
			this.root = root;
		}
	
		/// <summary>Gets the parent of this object in the hierarchy.</summary>
		public RootedFileSystemDirectory Parent {
			get {
				this.ThrowIfDefault();
				var greenParent = this.root.GetParent(this.FileSystemEntry);
				return greenParent != null ? greenParent.WithRoot(this.root) : default(RootedFileSystemDirectory);
			}
		}
	
		public RootedFileSystemDirectory Root {
			get { return this.root != null ? this.root.AsRoot : default(RootedFileSystemDirectory); }
		}
	
		public System.Int32 Identity {
			get {
				this.ThrowIfDefault();
				return this.greenNode.Identity;
			}
		}
	
		public bool IsFileSystemFile {
			get { return this.greenNode is FileSystemFile; }
		}
	
		public RootedFileSystemFile AsFileSystemFile {
			get { return this.greenNode != null ? ((FileSystemFile)this.greenNode).WithRoot(this.root) : default(RootedFileSystemFile); }
		}
	
		public bool IsFileSystemDirectory {
			get { return this.greenNode is FileSystemDirectory; }
		}
	
		public RootedFileSystemDirectory AsFileSystemDirectory {
			get { return this.greenNode != null ? ((FileSystemDirectory)this.greenNode).WithRoot(this.root) : default(RootedFileSystemDirectory); }
		}
	
		public System.String PathSegment {
			get {
				this.ThrowIfDefault();
				return this.greenNode.PathSegment;
			}
		}
		
		/// <summary>Returns a new instance with the PathSegment property set to the specified value.</summary>
		public RootedFileSystemEntry WithPathSegment(System.String value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithPathSegment(value);
			return this.NewSpine(mutatedLeaf);
		}
	
		/// <summary>Gets the unrooted representation of this object in the hierarchy.</summary>
		public FileSystemEntry FileSystemEntry {
			get { return this.greenNode; }
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public RootedFileSystemEntry With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>)) {
			this.ThrowIfDefault();
			var newGreenNode = this.greenNode.With(
				pathSegment: pathSegment);
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return newGreenNode.WithRoot(newRoot);
		}
	
		public System.Collections.Generic.IReadOnlyList<DiffGram<FileSystemEntry, FileSystemEntryChangedProperties>> ChangesSince(RootedFileSystemEntry priorVersion) {
			this.ThrowIfDefault();
			return this.greenNode.ChangesSince(priorVersion.FileSystemEntry);
		}
		
		public RootedFileSystemFile ToFileSystemFile(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>)) {
			var newGreenNode = this.greenNode.ToFileSystemFile(
					attributes: attributes);
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return newGreenNode.WithRoot(newRoot);
		}
		
		public RootedFileSystemDirectory ToFileSystemDirectory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>>)) {
			var newGreenNode = this.greenNode.ToFileSystemDirectory(
					children: children.IsDefined ? (System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>)((Adapters.IImmutableCollectionAdapter<FileSystemEntry>)children.Value).UnderlyingCollection : default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>));
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return newGreenNode.WithRoot(newRoot);
		}
	
		public override bool Equals(object obj) {
			if (obj is RootedFileSystemEntry) {
				var other = (RootedFileSystemEntry)obj;
				return this.Equals(other);
			}
	
			return false;
		}
	
		public bool Equals(RootedFileSystemEntry other) {
			return this.greenNode == other.greenNode && this.root == other.root;
		}
	
		public override int GetHashCode() {
			return this.greenNode == null ? 0 : this.greenNode.GetHashCode();
		}
	
		private RootedFileSystemEntry NewSpine(FileSystemEntry leaf) {
			var newRoot = this.root.ReplaceDescendent(this.greenNode, leaf);
			return leaf.WithRoot(newRoot);
		}
	
		/// <summary>Throws an exception if this struct does not have a backing FileSystemEntry.</summary>
		private void ThrowIfDefault() {
			if (this.greenNode == null) {
				throw new System.InvalidOperationException();
			}
		}
	}
	
	[System.Flags]
	public enum FileSystemEntryChangedProperties {
		/// <summary>
		/// No change was made to the node.  It was either entirely added or removed. 
		/// </summary>
		None = 0x0,
	
		/// <summary>
		/// The type of the node was changed.
		/// </summary>
		Type = 0x1,
	
		/// <summary>
		/// The node's position within its parent's list of children changed.
		/// </summary>
		PositionUnderParent = 0x2,
	
		/// <summary>
		/// The <see cref="FileSystemEntry.PathSegment" /> property was changed.
		/// </summary>
		PathSegment = 0x4,
	
		/// <summary>
		/// The <see cref="FileSystemFile.Attributes" /> property was changed.
		/// </summary>
		Attributes = 0x8,
	
		/// <summary>
		/// All flags in this enum.
		/// </summary>
		All = Type | PositionUnderParent | PathSegment | Attributes,
	}
	
	public interface IFileSystemFile : IFileSystemEntry {
		System.Collections.Immutable.ImmutableHashSet<System.String> Attributes { get; }
	}
	
	public partial class FileSystemFile : FileSystemEntry, IFileSystemFile {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly FileSystemFile DefaultInstance = GetDefaultTemplate();
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Collections.Immutable.ImmutableHashSet<System.String> attributes;
	
		/// <summary>Initializes a new instance of the FileSystemFile class.</summary>
		protected FileSystemFile(
			System.Int32 identity,
			System.String pathSegment,
			System.Collections.Immutable.ImmutableHashSet<System.String> attributes)
			: base(
				identity: identity,
				pathSegment: pathSegment)
		{
			this.attributes = attributes;
			this.Validate();
		}
	
		public static FileSystemFile Create(
			System.String pathSegment,
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				pathSegment: pathSegment,
				attributes: Optional.For(attributes.GetValueOrDefault(DefaultInstance.Attributes)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public System.Collections.Immutable.ImmutableHashSet<System.String> Attributes {
			get { return this.attributes; }
		}
		
		/// <summary>Returns a new instance with the PathSegment property set to the specified value.</summary>
		public new FileSystemFile WithPathSegment(System.String value) {
			return (FileSystemFile)base.WithPathSegment(value);
		}
		
		/// <summary>Returns a new instance with the Attributes property set to the specified value.</summary>
		public FileSystemFile WithAttributes(System.Collections.Immutable.ImmutableHashSet<System.String> value) {
			if (value == this.Attributes) {
				return this;
			}
		
			return this.With(attributes: Optional.For(value));
		}
		
		/// <summary>Replaces the elements of the Attributes collection with the specified collection.</summary>
		public FileSystemFile WithAttributes(params System.String[] values) {
			return this.With(attributes: this.Attributes.ResetContents(values));
		}
		
		/// <summary>Replaces the elements of the Attributes collection with the specified collection.</summary>
		public FileSystemFile WithAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			return this.With(attributes: this.Attributes.ResetContents(values));
		}
		
		/// <summary>Adds the specified elements from the Attributes collection.</summary>
		public FileSystemFile AddAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			return this.With(attributes: this.Attributes.AddRange(values));
		}
		
		/// <summary>Adds the specified elements from the Attributes collection.</summary>
		public FileSystemFile AddAttributes(params System.String[] values) {
			return this.With(attributes: this.Attributes.AddRange(values));
		}
		
		/// <summary>Adds the specified element from the Attributes collection.</summary>
		public FileSystemFile AddAttributes(System.String value) {
			return this.With(attributes: this.Attributes.Add(value));
		}
		
		/// <summary>Removes the specified elements from the Attributes collection.</summary>
		public FileSystemFile RemoveAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			return this.With(attributes: this.Attributes.RemoveRange(values));
		}
		
		/// <summary>Removes the specified elements from the Attributes collection.</summary>
		public FileSystemFile RemoveAttributes(params System.String[] values) {
			return this.With(attributes: this.Attributes.RemoveRange(values));
		}
		
		/// <summary>Removes the specified element from the Attributes collection.</summary>
		public FileSystemFile RemoveAttributes(System.String value) {
			return this.With(attributes: this.Attributes.Remove(value));
		}
		
		/// <summary>Clears all elements from the Attributes collection.</summary>
		public FileSystemFile RemoveAttributes() {
			return this.With(attributes: this.Attributes.Clear());
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public override FileSystemEntry With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>)) {
			return this.With(
				pathSegment: pathSegment,
				attributes: default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>));
		}
			
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public virtual FileSystemFile With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.Int32>);
			return this.WithFactory(
				pathSegment: pathSegment.GetValueOrDefault(this.PathSegment),
				attributes: Optional.For(attributes.GetValueOrDefault(this.Attributes)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private FileSystemFile WithFactory(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>),
			ImmutableObjectGraph.Optional<System.Int32> identity = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(pathSegment.IsDefined && pathSegment.Value != this.PathSegment) || 
				(attributes.IsDefined && attributes.Value != this.Attributes)) {
				return new FileSystemFile(
					identity: identity.GetValueOrDefault(this.Identity),
					pathSegment: pathSegment.GetValueOrDefault(this.PathSegment),
					attributes: attributes.GetValueOrDefault(this.Attributes));
			} else {
				return this;
			}
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated FileSystemFile whose fields are initialized with default values.</summary>
		private static FileSystemFile GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new FileSystemFile(
				default(System.Int32), 
				template.PathSegment, 
				template.Attributes);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.String PathSegment { get; set; }
	
			internal System.Collections.Immutable.ImmutableHashSet<System.String> Attributes { get; set; }
		}
		
		public new RootedFileSystemFile WithRoot(FileSystemDirectory root) {
			var spine = root.GetSpine(this);
			if (spine.IsEmpty) {
				throw new System.ArgumentException("Root does not belong to the same tree.");
			}
		
			return new RootedFileSystemFile(this, root);
		}
		
		protected override FileSystemEntryChangedProperties DiffProperties(FileSystemEntry other) {
			var propertiesChanged = base.DiffProperties(other);
		
			var otherFileSystemFile = other as FileSystemFile;
			if (otherFileSystemFile != null) {
				if (this.Attributes != otherFileSystemFile.Attributes) {
					propertiesChanged |= FileSystemEntryChangedProperties.Attributes;
				}
			}
		
			return propertiesChanged;
		}
		
		public new Builder ToBuilder() {
			return new Builder(this);
		}
		
		public new partial class Builder : FileSystemEntry.Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private FileSystemFile immutable;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>.Builder> attributes;
		
			internal Builder(FileSystemFile immutable) : base(immutable) {
				this.immutable = immutable;
		
			}
		
			public System.Collections.Immutable.ImmutableHashSet<System.String>.Builder Attributes {
				get {
					if (!this.attributes.IsDefined) {
						this.attributes = this.immutable.attributes != null ? this.immutable.attributes.ToBuilder() : null;
					}
		
					return this.attributes.Value;
				}
		
				set {
					this.attributes = value;
				}
			}
		
			public new FileSystemFile ToImmutable() {
				var attributes = this.attributes.IsDefined ? (this.attributes.Value != null ? this.attributes.Value.ToImmutable() : null) : this.immutable.Attributes;
				return this.immutable = this.immutable.With(
					ImmutableObjectGraph.Optional.For(this.PathSegment),
					ImmutableObjectGraph.Optional.For(attributes));
			}
		}
	}
	
	public partial struct RootedFileSystemFile : System.IEquatable<RootedFileSystemFile> {
		private readonly FileSystemFile greenNode;
	
		private readonly FileSystemDirectory root;
	
		internal RootedFileSystemFile(FileSystemFile fileSystemFile, FileSystemDirectory root) {
			this.greenNode = fileSystemFile;
			this.root = root;
		}
	
		/// <summary>Gets the parent of this object in the hierarchy.</summary>
		public RootedFileSystemDirectory Parent {
			get {
				this.ThrowIfDefault();
				var greenParent = this.root.GetParent(this.FileSystemFile);
				return greenParent != null ? greenParent.WithRoot(this.root) : default(RootedFileSystemDirectory);
			}
		}
	
		public RootedFileSystemDirectory Root {
			get { return this.root != null ? this.root.AsRoot : default(RootedFileSystemDirectory); }
		}
	
		public System.Int32 Identity {
			get {
				this.ThrowIfDefault();
				return this.greenNode.Identity;
			}
		}
	
		public RootedFileSystemEntry AsFileSystemEntry {
			get { return this.greenNode != null ? ((FileSystemEntry)this.greenNode).WithRoot(this.root) : default(RootedFileSystemEntry); }
		}
	
		public System.String PathSegment {
			get {
				this.ThrowIfDefault();
				return this.greenNode.PathSegment;
			}
		}
		
		/// <summary>Returns a new instance with the PathSegment property set to the specified value.</summary>
		public RootedFileSystemFile WithPathSegment(System.String value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithPathSegment(value);
			return this.NewSpine(mutatedLeaf);
		}
	
		public System.Collections.Immutable.ImmutableHashSet<System.String> Attributes {
			get {
				this.ThrowIfDefault();
				return this.greenNode.Attributes;
			}
		}
		
		/// <summary>Returns a new instance with the Attributes property set to the specified value.</summary>
		public RootedFileSystemFile WithAttributes(System.Collections.Immutable.ImmutableHashSet<System.String> value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithAttributes(value);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Replaces the elements of the Attributes collection with the specified collection.</summary>
		public RootedFileSystemFile WithAttributes(params System.String[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithAttributes(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Replaces the elements of the Attributes collection with the specified collection.</summary>
		public RootedFileSystemFile WithAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithAttributes(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified elements from the Attributes collection.</summary>
		public RootedFileSystemFile AddAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddAttributes(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified elements from the Attributes collection.</summary>
		public RootedFileSystemFile AddAttributes(params System.String[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddAttributes(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified element from the Attributes collection.</summary>
		public RootedFileSystemFile AddAttributes(System.String value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddAttributes(value);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified elements from the Attributes collection.</summary>
		public RootedFileSystemFile RemoveAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveAttributes(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified elements from the Attributes collection.</summary>
		public RootedFileSystemFile RemoveAttributes(params System.String[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveAttributes(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified element from the Attributes collection.</summary>
		public RootedFileSystemFile RemoveAttributes(System.String value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveAttributes(value);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Clears all elements from the Attributes collection.</summary>
		public RootedFileSystemFile RemoveAttributes() {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveAttributes();
			return this.NewSpine(mutatedLeaf);
		}
	
		/// <summary>Gets the unrooted representation of this object in the hierarchy.</summary>
		public FileSystemFile FileSystemFile {
			get { return this.greenNode; }
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public RootedFileSystemFile With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>)) {
			this.ThrowIfDefault();
			var newGreenNode = this.greenNode.With(
				pathSegment: pathSegment,
				attributes: attributes);
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return newGreenNode.WithRoot(newRoot);
		}
	
		public System.Collections.Generic.IReadOnlyList<DiffGram<FileSystemEntry, FileSystemEntryChangedProperties>> ChangesSince(RootedFileSystemFile priorVersion) {
			this.ThrowIfDefault();
			return this.greenNode.ChangesSince(priorVersion.FileSystemFile);
		}
		
		public RootedFileSystemDirectory ToFileSystemDirectory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>>)) {
			var newGreenNode = this.greenNode.ToFileSystemDirectory(
					children: children.IsDefined ? (System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>)((Adapters.IImmutableCollectionAdapter<FileSystemEntry>)children.Value).UnderlyingCollection : default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>));
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return newGreenNode.WithRoot(newRoot);
		}
	
		public override bool Equals(object obj) {
			if (obj is RootedFileSystemFile) {
				var other = (RootedFileSystemFile)obj;
				return this.Equals(other);
			}
	
			return false;
		}
	
		public bool Equals(RootedFileSystemFile other) {
			return this.greenNode == other.greenNode && this.root == other.root;
		}
	
		public override int GetHashCode() {
			return this.greenNode == null ? 0 : this.greenNode.GetHashCode();
		}
	
		private RootedFileSystemFile NewSpine(FileSystemFile leaf) {
			var newRoot = this.root.ReplaceDescendent(this.greenNode, leaf);
			return leaf.WithRoot(newRoot);
		}
	
		/// <summary>Throws an exception if this struct does not have a backing FileSystemFile.</summary>
		private void ThrowIfDefault() {
			if (this.greenNode == null) {
				throw new System.InvalidOperationException();
			}
		}
	}
	
	public interface IFileSystemDirectory : IFileSystemEntry {
		System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry> Children { get; }
	}
	
	public partial class FileSystemDirectory : FileSystemEntry, IFileSystemDirectory, System.Collections.Generic.IEnumerable<FileSystemEntry> {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly FileSystemDirectory DefaultInstance = GetDefaultTemplate();
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry> children;
	
		/// <summary>Initializes a new instance of the FileSystemDirectory class.</summary>
		protected FileSystemDirectory(
			System.Int32 identity,
			System.String pathSegment,
			System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry> children,
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableDictionary<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>>> lookupTable = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableDictionary<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>>>))
			: base(
				identity: identity,
				pathSegment: pathSegment)
		{
			this.children = children;
			this.Validate();
			this.InitializeLookup(lookupTable);
		}
	
		public static FileSystemDirectory Create(
			System.String pathSegment,
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				pathSegment: pathSegment,
				children: Optional.For(children.GetValueOrDefault(DefaultInstance.Children)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry> Children {
			get { return this.children; }
		}
		
		/// <summary>Returns a new instance with the PathSegment property set to the specified value.</summary>
		public new FileSystemDirectory WithPathSegment(System.String value) {
			return (FileSystemDirectory)base.WithPathSegment(value);
		}
		
		/// <summary>Returns a new instance with the Children property set to the specified value.</summary>
		public FileSystemDirectory WithChildren(System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry> value) {
			if (value == this.Children) {
				return this;
			}
		
			return this.With(children: Optional.For(value));
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public FileSystemDirectory WithChildren(params FileSystemEntry[] values) {
			return this.With(children: this.Children.ResetContents(values));
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public FileSystemDirectory WithChildren(System.Collections.Generic.IEnumerable<FileSystemEntry> values) {
			return this.With(children: this.Children.ResetContents(values));
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public FileSystemDirectory AddChildren(System.Collections.Generic.IEnumerable<FileSystemEntry> values) {
			return this.With(children: this.Children.AddRange(values));
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public FileSystemDirectory AddChildren(params FileSystemEntry[] values) {
			return this.With(children: this.Children.AddRange(values));
		}
		
		/// <summary>Adds the specified element from the Children collection.</summary>
		public FileSystemDirectory AddChildren(FileSystemEntry value) {
			return this.With(children: this.Children.Add(value));
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public FileSystemDirectory RemoveChildren(System.Collections.Generic.IEnumerable<FileSystemEntry> values) {
			return this.With(children: this.Children.RemoveRange(values));
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public FileSystemDirectory RemoveChildren(params FileSystemEntry[] values) {
			return this.With(children: this.Children.RemoveRange(values));
		}
		
		/// <summary>Removes the specified element from the Children collection.</summary>
		public FileSystemDirectory RemoveChildren(FileSystemEntry value) {
			return this.With(children: this.Children.Remove(value));
		}
		
		/// <summary>Clears all elements from the Children collection.</summary>
		public FileSystemDirectory RemoveChildren() {
			return this.With(children: this.Children.Clear());
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public override FileSystemEntry With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>)) {
			return this.With(
				pathSegment: pathSegment,
				children: default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>));
		}
			
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public virtual FileSystemDirectory With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.Int32>);
			return this.WithFactory(
				pathSegment: pathSegment.GetValueOrDefault(this.PathSegment),
				children: Optional.For(children.GetValueOrDefault(this.Children)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private FileSystemDirectory WithFactory(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>),
			ImmutableObjectGraph.Optional<System.Int32> identity = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(pathSegment.IsDefined && pathSegment.Value != this.PathSegment) || 
				(children.IsDefined && children.Value != this.Children)) {
				var lookupTable = children.IsDefined && children.Value != this.Children ? default(Optional<System.Collections.Immutable.ImmutableDictionary<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>>>) : Optional.For(this.lookupTable);
				return new FileSystemDirectory(
					identity: identity.GetValueOrDefault(this.Identity),
					pathSegment: pathSegment.GetValueOrDefault(this.PathSegment),
					children: children.GetValueOrDefault(this.Children),
					lookupTable: lookupTable);
			} else {
				return this;
			}
		}
	
		public System.Collections.Generic.IEnumerator<FileSystemEntry> GetEnumerator() {
			return this.children.GetEnumerator();
		}
	
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
			return this.children.GetEnumerator();
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated FileSystemDirectory whose fields are initialized with default values.</summary>
		private static FileSystemDirectory GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new FileSystemDirectory(
				default(System.Int32), 
				template.PathSegment, 
				template.Children);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.String PathSegment { get; set; }
	
			internal System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry> Children { get; set; }
		}
		
		public RootedFileSystemDirectory AsRoot {
			get { return new RootedFileSystemDirectory(this, this); }
		}
		
		public new RootedFileSystemDirectory WithRoot(FileSystemDirectory root) {
			var spine = root.GetSpine(this);
			if (spine.IsEmpty) {
				throw new System.ArgumentException("Root does not belong to the same tree.");
			}
		
			return new RootedFileSystemDirectory(this, root);
		}
		
		public override System.Collections.Generic.IReadOnlyList<DiffGram<FileSystemEntry, FileSystemEntryChangedProperties>> ChangesSince(FileSystemEntry priorVersion) {
			if (priorVersion == null) {
				throw new System.ArgumentNullException("priorVersion");
			}
		
			if (this == priorVersion) {
				return System.Collections.Immutable.ImmutableList.Create<DiffGram<FileSystemEntry, FileSystemEntryChangedProperties>>();
			}
		
			if (priorVersion.Identity != this.Identity) {
				throw new System.ArgumentException("Not another version of the same node.", "priorVersion");
			}
		
			var history = new System.Collections.Generic.List<DiffGram<FileSystemEntry, FileSystemEntryChangedProperties>>();
		
			var other = (FileSystemDirectory) priorVersion;
		
			var added = this.Children.Except(other.Children);
			var removed = other.Children.Except(this.Children);
			var common = from child in this.Children.Intersect(other.Children)
			             select new { Prior = other.Find(child.Identity), Current = this.Find(child.Identity) };
		
			history.AddRange(removed.Select(remove => DiffGram<FileSystemEntry, FileSystemEntryChangedProperties>.Remove(remove)));
			history.AddRange(base.ChangesSince(other));
			history.AddRange(common.SelectMany(change => change.Current.ChangesSince(change.Prior)));
			history.AddRange(added.Select(add => DiffGram<FileSystemEntry, FileSystemEntryChangedProperties>.Add(add)));
		
			return history;
		}
		
		public FileSystemDirectory AddDescendent(FileSystemEntry value, FileSystemDirectory parent) {
			var spine = this.GetSpine(parent);
			var newParent = parent.AddChildren(value);
			var newSpine = System.Collections.Immutable.ImmutableStack.Create(value, newParent);
			return (FileSystemDirectory)this.ReplaceDescendent(spine, newSpine, spineIncludesDeletedElement: false).Peek();
		}
		
		public FileSystemDirectory RemoveDescendent(FileSystemEntry value) {
			var spine = this.GetSpine(value);
			var parent = (FileSystemDirectory)spine.Reverse().Skip(1).First(); // second-to-last element in spine.
			var newParent = parent.RemoveChildren(value);
		
			var newSpine = System.Collections.Immutable.ImmutableStack.Create((FileSystemEntry)newParent);
			return (FileSystemDirectory)this.ReplaceDescendent(spine, newSpine, spineIncludesDeletedElement: true).Peek();
		}
		
		public FileSystemDirectory ReplaceDescendent(FileSystemEntry current, FileSystemEntry replacement) {
			var spine = this.GetSpine(current);
		
			if (spine.IsEmpty) {
				// The descendent was not found.
				throw new System.ArgumentException("Old value not found");
			}
		
			return (FileSystemDirectory)this.ReplaceDescendent(spine, System.Collections.Immutable.ImmutableStack.Create(replacement), spineIncludesDeletedElement: false).Peek();
		}
		
		private System.Collections.Immutable.ImmutableStack<FileSystemEntry> ReplaceDescendent(System.Collections.Immutable.ImmutableStack<FileSystemEntry> spine, System.Collections.Immutable.ImmutableStack<FileSystemEntry> replacementStackTip, bool spineIncludesDeletedElement) {
			Debug.Assert(this == spine.Peek());
			var remainingSpine = spine.Pop();
			if (remainingSpine.IsEmpty || (spineIncludesDeletedElement && remainingSpine.Pop().IsEmpty)) {
				// This is the instance to be changed.
				return replacementStackTip;
			}
		
			System.Collections.Immutable.ImmutableStack<FileSystemEntry> newChildSpine;
			var child = remainingSpine.Peek();
			var recursiveChild = child as FileSystemDirectory;
			if (recursiveChild != null) {
				newChildSpine = recursiveChild.ReplaceDescendent(remainingSpine, replacementStackTip, spineIncludesDeletedElement);
			} else {
				Debug.Assert(remainingSpine.Pop().IsEmpty); // we should be at the tail of the stack, since we're at a leaf.
				Debug.Assert(this.Children.Contains(child));
				newChildSpine = replacementStackTip;
			}
		
			var newChildren = this.Children.Replace(child, newChildSpine.Peek());
			var newSelf = this.WithChildren(newChildren);
			if (newSelf.lookupTable == lookupTableLazySentinal && this.lookupTable != null && this.lookupTable != lookupTableLazySentinal) {
				// Our newly mutated self wants a lookup table. If we already have one we can use it,
				// but it needs to be fixed up given the newly rewritten spine through our descendents.
				newSelf.lookupTable = this.FixupLookupTable(ImmutableDeque.Create(newChildSpine), ImmutableDeque.Create(remainingSpine));
				newSelf.ValidateInternalIntegrityDebugOnly();
			}
		
			return newChildSpine.Push(newSelf);
		}
		
		/// <summary>
		/// Produces a fast lookup table based on an existing one, if this node has one, to account for an updated spine among its descendents.
		/// </summary>
		/// <param name="updatedSpine">
		/// The spine of this node's new descendents' instances that are created for this change.
		/// The head is an immediate child of the new instance for this node.
		/// The tail is the node that was added or replaced.
		/// </param>
		/// <param name="oldSpine">
		/// The spine of this node's descendents that have been changed in this delta.
		/// The head is an immediate child of this instance.
		/// The tail is the node that was removed or replaced.
		/// </param>
		/// <returns>An updated lookup table.</returns>
		private System.Collections.Immutable.ImmutableDictionary<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>> FixupLookupTable(ImmutableObjectGraph.ImmutableDeque<FileSystemEntry> updatedSpine, ImmutableObjectGraph.ImmutableDeque<FileSystemEntry> oldSpine) {
			if (this.lookupTable == null || this.lookupTable == lookupTableLazySentinal) {
				// We don't already have a lookup table to base this on, so leave it to the new instance to lazily construct.
				return lookupTableLazySentinal;
			}
		
			if ((updatedSpine.IsEmpty && oldSpine.IsEmpty) ||
				(updatedSpine.Count > 1 && oldSpine.Count > 1 && System.Object.ReferenceEquals(updatedSpine.PeekHead(), oldSpine.PeekHead()))) {
				// No changes were actually made.
				return this.lookupTable;
			}
		
			var lookupTable = this.lookupTable.ToBuilder();
		
			// Classify the kind of change that has just occurred.
			var oldSpineTail = oldSpine.PeekTail();
			var newSpineTail = updatedSpine.PeekTail();
			ChangeKind changeKind;
			bool childrenChanged = false;
			if (updatedSpine.Count == oldSpine.Count) {
				changeKind = ChangeKind.Replaced;
				var oldSpineTailRecursive = oldSpineTail as FileSystemDirectory;
				var newSpineTailRecursive = newSpineTail as FileSystemDirectory;
				if (oldSpineTailRecursive != null || newSpineTailRecursive != null) {
					// Children have changed if either before or after type didn't have a children property,
					// or if both did, but the children actually changed.
					childrenChanged = oldSpineTailRecursive == null || newSpineTailRecursive == null
						|| !System.Object.ReferenceEquals(oldSpineTailRecursive.Children, newSpineTailRecursive.Children);
				}
			} else if (updatedSpine.Count > oldSpine.Count) {
				changeKind = ChangeKind.Added;
			} else // updatedSpine.Count < oldSpine.Count
			{
				changeKind = ChangeKind.Removed;
			}
		
			// Trim the lookup table of any entries for nodes that have been removed from the tree.
			if (childrenChanged || changeKind == ChangeKind.Removed) {
				// We need to remove all descendents of the old tail node.
				lookupTable.RemoveRange(oldSpineTail.GetSelfAndDescendents().Select(n => n.Identity));
			} else if (changeKind == ChangeKind.Replaced && oldSpineTail.Identity != newSpineTail.Identity) {
				// The identity of the node was changed during the replacement.  We must explicitly remove the old entry
				// from our lookup table in this case.
				lookupTable.Remove(oldSpineTail.Identity);
		
				// We also need to update any immediate children of the old spine tail
				// because the identity of their parent has changed.
				var oldSpineTailRecursive = oldSpineTail as FileSystemDirectory;
				if (oldSpineTailRecursive != null) {
					foreach (var child in oldSpineTailRecursive) {
						lookupTable[child.Identity] = new System.Collections.Generic.KeyValuePair<FileSystemEntry, int>(child, newSpineTail.Identity);
					}
				}
			}
		
			// Update our lookup table so that it includes (updated) entries for every member of the spine itself.
			FileSystemEntry parent = this;
			foreach (var node in updatedSpine) {
				// Remove and add rather than use the Set method, since the old and new node are equal (in identity) therefore the map class will
				// assume no change is relevant and not apply the change.
				lookupTable.Remove(node.Identity);
				lookupTable.Add(node.Identity, new System.Collections.Generic.KeyValuePair<FileSystemEntry, int>(node, parent.Identity));
				parent = node;
			}
		
			// There may be children on the added node that we should include.
			if (childrenChanged || changeKind == ChangeKind.Added) {
				var recursiveParent = parent as FileSystemDirectory;
				if (recursiveParent != null) {
					recursiveParent.ContributeDescendentsToLookupTable(lookupTable);
				}
			}
		
			return lookupTable.ToImmutable();
		}
		
		public override System.Collections.Generic.IEnumerable<FileSystemEntry> GetSelfAndDescendents() {
			yield return this;
			foreach (var child in this.Children) {
				foreach (var descendent in child.GetSelfAndDescendents()) {
					yield return descendent;
				}
			}
		}
		
		/// <summary>
		/// Validates this node and all its descendents <em>only in DEBUG builds</em>.
		/// </summary>
		[Conditional("DEBUG")]
		private void ValidateInternalIntegrityDebugOnly() {
			this.ValidateInternalIntegrity();
		}
		
		/// <summary>
		/// Validates this node and all its descendents.
		/// </summary>
		protected internal void ValidateInternalIntegrity() {
			// Each node id appears at most once.
			var observedIdentities = new System.Collections.Generic.HashSet<int>();
			foreach (var node in this.GetSelfAndDescendents()) {
				if (!observedIdentities.Add(node.Identity)) {
					throw new RecursiveChildNotUniqueException(node.Identity);
				}
			}
		
			// The lookup table (if any) accurately describes the contents of this tree.
			if (this.lookupTable != null && this.lookupTable != lookupTableLazySentinal) {
				// The table should have one entry for every *descendent* of this node (not this node itself).
				int expectedCount = this.GetSelfAndDescendents().Count() - 1;
				int actualCount = this.lookupTable.Count;
				if (actualCount != expectedCount) {
					throw new System.ApplicationException(string.Format(System.Globalization.CultureInfo.CurrentCulture, "Expected {0} entries in lookup table but found {1}.", expectedCount, actualCount));
				}
		
				this.ValidateLookupTable(this.lookupTable);
			}
		}
		
		/// <summary>
		/// Validates that the contents of a lookup table are valid for all descendent nodes of this node.
		/// </summary>
		/// <param name="lookupTable">The lookup table being validated.</param>
		private void ValidateLookupTable(System.Collections.Immutable.ImmutableDictionary<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>> lookupTable) {
			const string ErrorString = "Lookup table integrity failure.";
		
			foreach (var child in this.Children) {
				var entry = lookupTable[child.Identity];
				if (!object.ReferenceEquals(entry.Key, child)) {
					throw new System.ApplicationException(ErrorString);
				}
		
				if (entry.Value != this.Identity) {
					throw new System.ApplicationException(ErrorString);
				}
		
				var recursiveChild = child as FileSystemDirectory;
				if (recursiveChild != null) {
					recursiveChild.ValidateLookupTable(lookupTable);
				}
			}
		}
		
		
		
		private static readonly System.Collections.Immutable.ImmutableDictionary<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>> lookupTableLazySentinal = System.Collections.Immutable.ImmutableDictionary.Create<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>>().Add(default(System.Int32), new System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>());
		
		private System.Collections.Immutable.ImmutableDictionary<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>> lookupTable;
		
		private int inefficiencyLoad;
		
		/// <summary>
		/// The maximum number of steps allowable for a search to be done among this node's children
		/// before a faster lookup table will be built.
		/// </summary>
		private const int InefficiencyLoadThreshold = 16;
		
		private System.Collections.Immutable.ImmutableDictionary<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>> LookupTable {
			get {
				if (this.lookupTable == lookupTableLazySentinal) {
					this.lookupTable = this.CreateLookupTable();
					this.inefficiencyLoad = 1;
				}
		
				return this.lookupTable;
			}
		}
		
		private void InitializeLookup(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableDictionary<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>>> priorLookupTable = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableDictionary<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>>>)) {
			this.inefficiencyLoad = 1;
			if (priorLookupTable.IsDefined && priorLookupTable.Value != null) {
				this.lookupTable = priorLookupTable.Value;
			} else {
				foreach (var child in this.children)
				{
					var recursiveChild = child as FileSystemDirectory;
					this.inefficiencyLoad += recursiveChild != null ? recursiveChild.inefficiencyLoad : 1;
				}
		
				if (this.inefficiencyLoad > InefficiencyLoadThreshold) {
					this.inefficiencyLoad = 1;
					this.lookupTable = lookupTableLazySentinal;
				}
			}
		
			this.ValidateInternalIntegrityDebugOnly();
		}
		
		/// <summary>
		/// Creates the lookup table that will contain all this node's children.
		/// </summary>
		/// <returns>The lookup table.</returns>
		private System.Collections.Immutable.ImmutableDictionary<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>> CreateLookupTable() {
			var table = System.Collections.Immutable.ImmutableDictionary.Create<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>>().ToBuilder();
			this.ContributeDescendentsToLookupTable(table);
			return table.ToImmutable();
		}
		
		/// <summary>
		/// Adds this node's children (recursively) to the lookup table.
		/// </summary>
		/// <param name="seedLookupTable">The lookup table to add entries to.</param>
		/// <returns>The new lookup table.</returns>
		private void ContributeDescendentsToLookupTable(System.Collections.Immutable.ImmutableDictionary<System.Int32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>>.Builder seedLookupTable)
		{
			foreach (var child in this.Children)
			{
				seedLookupTable.Add(child.Identity, new System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32>(child, this.Identity));
				var recursiveChild = child as FileSystemDirectory;
				if (recursiveChild != null) {
					recursiveChild.ContributeDescendentsToLookupTable(seedLookupTable);
				}
			}
		}
		
		public FileSystemEntry Find(System.Int32 identity) {
			if (this.Identity.Equals(identity)) {
				return this;
			}
		
			if (this.LookupTable != null) {
				System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32> lookupValue;
				if (this.LookupTable.TryGetValue(identity, out lookupValue)) {
					return lookupValue.Key;
				}
			} else {
				// No lookup table means we have to aggressively search each child.
				foreach (var child in this.Children) {
					var recursiveChild = child as FileSystemDirectory;
					if (recursiveChild != null) {
						var result = recursiveChild.Find(identity);
						if (result != null) {
							return result;
						}
					} else {
						if (child.Identity.Equals(identity)) {
							return child;
						}
					}
				}
			}
		
			return null;
		}
		
		/// <summary>Gets the recursive parent of the specified value, or <c>null</c> if none could be found.</summary>
		internal FileSystemDirectory GetParent(FileSystemEntry descendent) {
			if (this.LookupTable != null) {
				System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32> lookupValue;
				if (this.LookupTable.TryGetValue(descendent.Identity, out lookupValue)) {
					var parentIdentity = lookupValue.Value;
					return (FileSystemDirectory)this.LookupTable[parentIdentity].Key;
				}
			} else {
				// No lookup table means we have to aggressively search each child.
				foreach (var child in this.Children) {
					if (child.Identity.Equals(descendent.Identity)) {
						return this;
					}
		
					var recursiveChild = child as FileSystemDirectory;
					if (recursiveChild != null) {
						var childResult = recursiveChild.GetParent(descendent);
						if (childResult != null) {
							return childResult;
						}
					} 
				}
			}
		
			return null;
		}
		
		internal System.Collections.Immutable.ImmutableStack<FileSystemEntry> GetSpine(System.Int32 descendent) {
			var emptySpine = System.Collections.Immutable.ImmutableStack.Create<FileSystemEntry>();
			if (this.Identity.Equals(descendent)) {
				return emptySpine.Push(this);
			}
		
			if (this.LookupTable != null) {
				System.Collections.Generic.KeyValuePair<FileSystemEntry, System.Int32> lookupValue;
				if (this.LookupTable.TryGetValue(descendent, out lookupValue))
				{
					// Awesome.  We know the node the caller is looking for is a descendent of this node.
					// Now just string together all the nodes that connect this one with the sought one.
					var spine = emptySpine;
					do
					{
						spine = spine.Push(lookupValue.Key);
					}
					while (this.lookupTable.TryGetValue(lookupValue.Value, out lookupValue));
					return spine.Push(this);
				}
			} else {
				// We don't have an efficient lookup table for this node.  Aggressively search every child.
				var spine = emptySpine;
				foreach (var child in this.Children) {
					var recursiveChild = child as FileSystemDirectory;
					if (recursiveChild != null) {
						spine = recursiveChild.GetSpine(descendent);
					} else if (child.Identity.Equals(descendent)) {
						spine = spine.Push(child);
					}
		
					if (!spine.IsEmpty) {
						return spine.Push(this);
					}
				}
			}
		
			// The descendent is not in this sub-tree.
			return emptySpine;
		}
		
		internal System.Collections.Immutable.ImmutableStack<FileSystemEntry> GetSpine(FileSystemEntry descendent) {
			return this.GetSpine(descendent.Identity);
		}
		
		public new Builder ToBuilder() {
			return new Builder(this);
		}
		
		public new partial class Builder : FileSystemEntry.Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private FileSystemDirectory immutable;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>.Builder> children;
		
			internal Builder(FileSystemDirectory immutable) : base(immutable) {
				this.immutable = immutable;
		
			}
		
			public System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>.Builder Children {
				get {
					if (!this.children.IsDefined) {
						this.children = this.immutable.children != null ? this.immutable.children.ToBuilder() : null;
					}
		
					return this.children.Value;
				}
		
				set {
					this.children = value;
				}
			}
		
			public new FileSystemDirectory ToImmutable() {
				var children = this.children.IsDefined ? (this.children.Value != null ? this.children.Value.ToImmutable() : null) : this.immutable.Children;
				return this.immutable = this.immutable.With(
					ImmutableObjectGraph.Optional.For(this.PathSegment),
					ImmutableObjectGraph.Optional.For(children));
			}
		}
	}
	
	public partial struct RootedFileSystemDirectory : System.IEquatable<RootedFileSystemDirectory> {
		private static readonly System.Func<RootedFileSystemEntry, FileSystemEntry> toUnrooted = r => r.FileSystemEntry;
		private static readonly System.Func<FileSystemEntry, FileSystemDirectory, RootedFileSystemEntry> toRooted = (u, r) => u.WithRoot(r);
	
		private readonly FileSystemDirectory greenNode;
	
		private readonly FileSystemDirectory root;
		private Optional<Adapters.ImmutableSetRootAdapter<FileSystemEntry, RootedFileSystemEntry, FileSystemDirectory>> children;
	
		internal RootedFileSystemDirectory(FileSystemDirectory fileSystemDirectory, FileSystemDirectory root) {
			this.greenNode = fileSystemDirectory;
			this.root = root;
			this.children = default(Optional<Adapters.ImmutableSetRootAdapter<FileSystemEntry, RootedFileSystemEntry, FileSystemDirectory>>);
		}
	
		/// <summary>Gets the parent of this object in the hierarchy.</summary>
		public RootedFileSystemDirectory Parent {
			get {
				this.ThrowIfDefault();
				var greenParent = this.root.GetParent(this.FileSystemDirectory);
				return greenParent != null ? greenParent.WithRoot(this.root) : default(RootedFileSystemDirectory);
			}
		}
	
		public RootedFileSystemDirectory Root {
			get { return this.root != null ? this.root.AsRoot : default(RootedFileSystemDirectory); }
		}
	
		public System.Int32 Identity {
			get {
				this.ThrowIfDefault();
				return this.greenNode.Identity;
			}
		}
	
		public RootedFileSystemEntry AsFileSystemEntry {
			get { return this.greenNode != null ? ((FileSystemEntry)this.greenNode).WithRoot(this.root) : default(RootedFileSystemEntry); }
		}
	
		public bool IsRoot {
			get { return this.root == this.greenNode; }
		}
	
		public System.String PathSegment {
			get {
				this.ThrowIfDefault();
				return this.greenNode.PathSegment;
			}
		}
		
		/// <summary>Returns a new instance with the PathSegment property set to the specified value.</summary>
		public RootedFileSystemDirectory WithPathSegment(System.String value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithPathSegment(value);
			return this.NewSpine(mutatedLeaf);
		}
	
		public System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry> Children {
			get {
				if (!this.children.IsDefined) {
					this.ThrowIfDefault();
					this.children = Optional.For(Adapter.Create(this.greenNode.Children, toRooted, toUnrooted, this.root));
				}
	
				return this.children.Value;
			}
		}
		
		/// <summary>Returns a new instance with the Children property set to the specified value.</summary>
		public RootedFileSystemDirectory WithChildren(System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry> value) {
			this.ThrowIfDefault();
			var adapter = (Adapters.IImmutableCollectionAdapter<FileSystemEntry>)value;
			var mutatedLeaf = this.greenNode.WithChildren(adapter.UnderlyingCollection);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public RootedFileSystemDirectory WithChildren(params RootedFileSystemEntry[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithChildren(values.Select(r => r.FileSystemEntry));
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public RootedFileSystemDirectory WithChildren(System.Collections.Generic.IEnumerable<RootedFileSystemEntry> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithChildren(values.Select(r => r.FileSystemEntry));
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory AddChildren(System.Collections.Generic.IEnumerable<RootedFileSystemEntry> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddChildren(values.Select(r => r.FileSystemEntry));
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory AddChildren(params RootedFileSystemEntry[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddChildren(values.Select(r => r.FileSystemEntry));
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified element from the Children collection.</summary>
		public RootedFileSystemDirectory AddChildren(RootedFileSystemEntry value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddChildren(value.FileSystemEntry);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChildren(System.Collections.Generic.IEnumerable<RootedFileSystemEntry> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChildren(values.Select(r => r.FileSystemEntry));
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChildren(params RootedFileSystemEntry[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChildren(values.Select(r => r.FileSystemEntry));
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified element from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChildren(RootedFileSystemEntry value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChildren(value.FileSystemEntry);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public RootedFileSystemDirectory WithChildren(params FileSystemEntry[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithChildren(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public RootedFileSystemDirectory WithChildren(System.Collections.Generic.IEnumerable<FileSystemEntry> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithChildren(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory AddChildren(System.Collections.Generic.IEnumerable<FileSystemEntry> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddChildren(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory AddChildren(params FileSystemEntry[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddChildren(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified element from the Children collection.</summary>
		public RootedFileSystemDirectory AddChildren(FileSystemEntry value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddChildren(value);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChildren(System.Collections.Generic.IEnumerable<FileSystemEntry> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChildren(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChildren(params FileSystemEntry[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChildren(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified element from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChildren(FileSystemEntry value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChildren(value);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Clears all elements from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChildren() {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChildren();
			return this.NewSpine(mutatedLeaf);
		}
	
		/// <summary>Gets the unrooted representation of this object in the hierarchy.</summary>
		public FileSystemDirectory FileSystemDirectory {
			get { return this.greenNode; }
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public RootedFileSystemDirectory With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>>)) {
			this.ThrowIfDefault();
			var newGreenNode = this.greenNode.With(
				pathSegment: pathSegment,
				children: children.IsDefined ? (System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>)((Adapters.IImmutableCollectionAdapter<FileSystemEntry>)children.Value).UnderlyingCollection : default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>));
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return newGreenNode.WithRoot(newRoot);
		}
	
		public static RootedFileSystemDirectory Create(
			System.String pathSegment,
			ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>>)) {
			var greenNode = FileSystemDirectory.Create(
				pathSegment: pathSegment,
				children: children.IsDefined ? (System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>)((Adapters.IImmutableCollectionAdapter<FileSystemEntry>)children.Value).UnderlyingCollection : default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>));
			return greenNode.AsRoot;
		}
	
		public RootedFileSystemEntry Find(System.Int32 identity) {
			var found = this.greenNode.Find(identity);
			return found != null ? found.WithRoot(this.root) : default(RootedFileSystemEntry);
		}
	
		public System.Collections.Generic.IEnumerator<RootedFileSystemEntry> GetEnumerator() {
			return this.Children.GetEnumerator();
		}
	
		public System.Collections.Generic.IReadOnlyList<DiffGram<FileSystemEntry, FileSystemEntryChangedProperties>> ChangesSince(RootedFileSystemDirectory priorVersion) {
			this.ThrowIfDefault();
			return this.greenNode.ChangesSince(priorVersion.FileSystemDirectory);
		}
		
		public RootedFileSystemFile ToFileSystemFile(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>)) {
			var newGreenNode = this.greenNode.ToFileSystemFile(
					attributes: attributes);
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return newGreenNode.WithRoot(newRoot);
		}
	
		public override bool Equals(object obj) {
			if (obj is RootedFileSystemDirectory) {
				var other = (RootedFileSystemDirectory)obj;
				return this.Equals(other);
			}
	
			return false;
		}
	
		public bool Equals(RootedFileSystemDirectory other) {
			return this.greenNode == other.greenNode && this.root == other.root;
		}
	
		public override int GetHashCode() {
			return this.greenNode == null ? 0 : this.greenNode.GetHashCode();
		}
	
		private RootedFileSystemDirectory NewSpine(FileSystemDirectory leaf) {
			var newRoot = this.root.ReplaceDescendent(this.greenNode, leaf);
			return leaf.WithRoot(newRoot);
		}
	
		/// <summary>Throws an exception if this struct does not have a backing FileSystemDirectory.</summary>
		private void ThrowIfDefault() {
			if (this.greenNode == null) {
				throw new System.InvalidOperationException();
			}
		}
	}
}


