// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace ImmutableObjectGraph.Tests {
	using System.Diagnostics;
	using System.Linq;
	using ImmutableObjectGraph;
	
	public interface IFileSystemEntry {
		System.String PathSegment { get; }
		RichData Data { get; }
	}
	
	public abstract partial class FileSystemEntry : IFileSystemEntry, IRecursiveType, IRecursiveDiffingType<FileSystemEntryChangedProperties, FileSystemEntry.DiffGram> {
		
		/// <summary>The last identity assigned to a created instance.</summary>
		private static int lastIdentityProduced;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.String pathSegment;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly RichData data;
	
		private readonly System.UInt32 identity;
	
		/// <summary>Initializes a new instance of the FileSystemEntry class.</summary>
		protected FileSystemEntry(
			System.UInt32 identity,
			System.String pathSegment,
			RichData data,
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
		{
			this.identity = identity;
			this.pathSegment = pathSegment;
			this.data = data;
		}
	
		public System.String PathSegment {
			get { return this.pathSegment; }
		}
	
		public RichData Data {
			get { return this.data; }
		}
		
		/// <summary>Returns a new instance with the PathSegment property set to the specified value.</summary>
		public FileSystemEntry WithPathSegment(System.String value) {
			if (value == this.PathSegment) {
				return this;
			}
		
			return this.With(pathSegment: Optional.For(value));
		}
		
		/// <summary>Returns a new instance with the Data property set to the specified value.</summary>
		public FileSystemEntry WithData(RichData value) {
			if (value == this.Data) {
				return this;
			}
		
			return this.With(data: Optional.For(value));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public FileSystemEntry With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>)) {
			return (FileSystemEntry)this.WithCore(
				pathSegment: pathSegment,
				data: data);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected abstract FileSystemEntry WithCore(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>));
	
		protected internal uint Identity {
			get { return (uint)this.identity; }
		}
	
		/// <summary>Returns a unique identity that may be assigned to a newly created instance.</summary>
		protected static System.UInt32 NewIdentity() {
			return (System.UInt32)System.Threading.Interlocked.Increment(ref lastIdentityProduced);
		}
		
		public RootedFileSystemEntry WithRoot(FileSystemDirectory root) {
			var spine = root.GetSpine(this);
			if (spine.IsEmpty) {
				throw new System.ArgumentException("Root does not belong to the same tree.");
			}
		
			return new RootedFileSystemEntry(this, root);
		}
		
		/// <summary>
		/// A description of a change made to an instance of an immutable object.
		/// </summary>
		[DebuggerDisplay("{Kind} {(Before ?? After).Caption} ({Identity}) {Changes}")]
		public struct DiffGram {
			private DiffGram(FileSystemEntry before, FileSystemEntry after, ChangeKind kind, FileSystemEntryChangedProperties changes)
				: this() {
				this.Before = before;
				this.After = after;
				this.Kind = kind;
				this.Changes = changes;
			}
		
			public static DiffGram Change(FileSystemEntry before, FileSystemEntry after, FileSystemEntryChangedProperties changes) {
				return new DiffGram(before, after, ChangeKind.Replaced, changes);
			}
		
			public static DiffGram Add(FileSystemEntry value) {
				return new DiffGram(null, value, ChangeKind.Added, default(FileSystemEntryChangedProperties));
			}
		
			public static DiffGram Remove(FileSystemEntry value) {
				return new DiffGram(value, null, ChangeKind.Removed, default(FileSystemEntryChangedProperties));
			}
		
			/// <summary>
			/// Gets the leaf node before the change.
			/// </summary>
			public FileSystemEntry Before { get; private set; }
		
			/// <summary>
			/// Gets the leaf node after the change.
			/// </summary>
			public FileSystemEntry After { get; private set; }
		
			/// <summary>
			/// Gets the kind of change made to the alterered node.
			/// </summary>
			public ChangeKind Kind { get; private set; }
		
			/// <summary>
			/// Gets the kinds of changes made to node if <see cref="Kind"/> is <see cref="ChangeKind.Replaced"/>.
			/// </summary>
			public FileSystemEntryChangedProperties Changes { get; private set; }
		
			/// <summary>
			/// Gets a value indicating whether the <see cref="FileSystemEntry.PathSegment" /> was changed.
			/// </summary>
			public bool IsPathSegmentChanged {
				get { return (this.Changes & FileSystemEntryChangedProperties.PathSegment) != FileSystemEntryChangedProperties.None; }
			}
		
			/// <summary>
			/// Gets a value indicating whether the <see cref="FileSystemEntry.Data" /> was changed.
			/// </summary>
			public bool IsDataChanged {
				get { return (this.Changes & FileSystemEntryChangedProperties.Data) != FileSystemEntryChangedProperties.None; }
			}
		
			/// <summary>
			/// Gets the identity of the affected object.
			/// </summary>
			public System.UInt32 Identity {
				get { return (this.Before ?? this.After).Identity; }
			}
		}
		
		public static class Comparers {
			/// <summary>Gets an equatable comparer that considers only the persistent identity of a pair of values.</summary>
			public static System.Collections.Generic.IEqualityComparer<FileSystemEntry> Identity {
				get { return ImmutableObjectGraph.Comparers.Identity; }
			}
		
			/// <summary>Gets an equatable comparer that compares all properties between two instances.</summary>
			public static System.Collections.Generic.IEqualityComparer<FileSystemEntry> ByValue {
				get { return ImmutableObjectGraph.Comparers.ByValue<FileSystemEntryChangedProperties, DiffGram>(deep: false); }
			}
		
			/// <summary>Gets an equatable comparer that considers all properties between two instances and their children.</summary>
			public static System.Collections.Generic.IEqualityComparer<FileSystemEntry> ByValueWithDescendents {
				get { return ImmutableObjectGraph.Comparers.ByValue<FileSystemEntryChangedProperties, DiffGram>(deep: true); }
			}
		
			internal static System.Collections.Generic.IEqualityComparer<ParentedRecursiveType<FileSystemDirectory, FileSystemEntry>> ParentedFileSystemEntryIdentity {
				get { return ImmutableObjectGraph.Comparers.Parented<FileSystemDirectory, FileSystemEntry>(); }
			}
		}
		
		FileSystemEntryChangedProperties IRecursiveDiffingType<FileSystemEntryChangedProperties, FileSystemEntry.DiffGram>.ParentProperty {
			get { return FileSystemEntryChangedProperties.Parent; }
		}
		
		FileSystemEntryChangedProperties IRecursiveDiffingType<FileSystemEntryChangedProperties, FileSystemEntry.DiffGram>.PositionUnderParentProperty {
			get { return FileSystemEntryChangedProperties.PositionUnderParent; }
		}
		
		FileSystemEntryChangedProperties IRecursiveDiffingType<FileSystemEntryChangedProperties, FileSystemEntry.DiffGram>.DiffProperties(IRecursiveType other) {
			return this.DiffProperties((FileSystemEntry)other);
		}
		
		FileSystemEntry.DiffGram IRecursiveDiffingType<FileSystemEntryChangedProperties, FileSystemEntry.DiffGram>.Change(IRecursiveType before, IRecursiveType after, FileSystemEntryChangedProperties diff) {
			return DiffGram.Change((FileSystemEntry)before, (FileSystemEntry)after, diff);
		}
		
		FileSystemEntry.DiffGram IRecursiveDiffingType<FileSystemEntryChangedProperties, FileSystemEntry.DiffGram>.Add(IRecursiveType after) {
			return DiffGram.Add((FileSystemEntry)after);
		}
		
		FileSystemEntry.DiffGram IRecursiveDiffingType<FileSystemEntryChangedProperties, FileSystemEntry.DiffGram>.Remove(IRecursiveType before) {
			return DiffGram.Remove((FileSystemEntry)before);
		}
		
		bool IRecursiveDiffingType<FileSystemEntryChangedProperties, FileSystemEntry.DiffGram>.Equals(FileSystemEntryChangedProperties first, FileSystemEntryChangedProperties second) {
			return first == second;
		}
		
		FileSystemEntryChangedProperties IRecursiveDiffingType<FileSystemEntryChangedProperties, FileSystemEntry.DiffGram>.Union(FileSystemEntryChangedProperties first, FileSystemEntryChangedProperties second) {
			return first | second;
		}
		
		protected virtual FileSystemEntryChangedProperties DiffProperties(FileSystemEntry other) {
			if (other == null) {
				throw new System.ArgumentNullException("other");
			}
		
			var propertiesChanged = FileSystemEntryChangedProperties.None;
		
			if (this != other) {
				if (!this.GetType().IsEquivalentTo(other.GetType())) {
					propertiesChanged |= FileSystemEntryChangedProperties.Type;
				}
		
				if (this.PathSegment != other.PathSegment) {
					propertiesChanged |= FileSystemEntryChangedProperties.PathSegment;
				}
		
				if (this.Data != other.Data) {
					propertiesChanged |= FileSystemEntryChangedProperties.Data;
				}
			}
		
			return propertiesChanged;
		}
		
		public virtual FileSystemFile ToFileSystemFile(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>)) {
			FileSystemFile that = this as FileSystemFile;
			if (that != null && this.GetType().IsEquivalentTo(typeof(FileSystemFile))) {
				if ((!attributes.IsDefined || attributes.Value == that.Attributes)) {
					return that;
				}
			}
		
			return FileSystemFile.CreateWithIdentity(
				pathSegment: this.PathSegment,
				data: Optional.For(this.Data),
				identity: this.Identity,
				attributes: attributes);
		}
		
		public virtual FileSystemDirectory ToFileSystemDirectory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>)) {
			FileSystemDirectory that = this as FileSystemDirectory;
			if (that != null && this.GetType().IsEquivalentTo(typeof(FileSystemDirectory))) {
				if ((!children.IsDefined || children.Value == that.Children)) {
					return that;
				}
			}
		
			return FileSystemDirectory.CreateWithIdentity(
				pathSegment: this.PathSegment,
				data: Optional.For(this.Data),
				identity: this.Identity,
				children: children);
		}
	
		System.UInt32 IRecursiveType.Identity {
			get { return this.Identity; }
		}
	}
	
	public partial struct RootedFileSystemEntry : System.IEquatable<RootedFileSystemEntry>, IRecursiveType {
		private readonly FileSystemEntry greenNode;
	
		private readonly FileSystemDirectory root;
	
		internal RootedFileSystemEntry(FileSystemEntry fileSystemEntry, FileSystemDirectory root) {
			this.greenNode = fileSystemEntry;
			this.root = root;
		}
	
		public static implicit operator FileSystemEntry(RootedFileSystemEntry rooted) {
			return rooted.FileSystemEntry;
		}
	
		public static bool operator ==(RootedFileSystemEntry that, RootedFileSystemEntry other) {
			return that.FileSystemEntry == other.FileSystemEntry
			    && that.Root.FileSystemDirectory == other.Root.FileSystemDirectory;
		}
	
		public static bool operator !=(RootedFileSystemEntry that, RootedFileSystemEntry other) {
			return !(that == other);
		}
	
		/// <summary>Gets the parent of this object in the hierarchy.</summary>
		public RootedFileSystemDirectory Parent {
			get {
				this.ThrowIfDefault();
				var greenParent = this.root.GetParent(this.FileSystemEntry);
				return greenParent != null ? new RootedFileSystemDirectory(greenParent, this.root) : default(RootedFileSystemDirectory);
			}
		}
	
		public RootedFileSystemDirectory Root {
			get { return this.root != null ? this.root.AsRoot : default(RootedFileSystemDirectory); }
		}
	
		public uint Identity {
			get {
				this.ThrowIfDefault();
				return (uint)this.greenNode.Identity;
			}
		}
	
		public bool IsFileSystemFile {
			get { return this.greenNode is FileSystemFile; }
		}
	
		public RootedFileSystemFile AsFileSystemFile {
			get {
				var downcast = this.greenNode as FileSystemFile;
				return downcast != null ? new RootedFileSystemFile(downcast, this.root) : default(RootedFileSystemFile);
			}
		}
	
		public bool IsFileSystemDirectory {
			get { return this.greenNode is FileSystemDirectory; }
		}
	
		public RootedFileSystemDirectory AsFileSystemDirectory {
			get {
				var downcast = this.greenNode as FileSystemDirectory;
				return downcast != null ? new RootedFileSystemDirectory(downcast, this.root) : default(RootedFileSystemDirectory);
			}
		}
	
		public System.String PathSegment {
			get {
				this.ThrowIfDefault();
				return this.greenNode.PathSegment;
			}
		}
		
		/// <summary>Returns a new instance with the PathSegment property set to the specified value.</summary>
		public RootedFileSystemEntry WithPathSegment(System.String value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithPathSegment(value);
			return this.NewSpine(mutatedLeaf);
		}
	
		public RichData Data {
			get {
				this.ThrowIfDefault();
				return this.greenNode.Data;
			}
		}
		
		/// <summary>Returns a new instance with the Data property set to the specified value.</summary>
		public RootedFileSystemEntry WithData(RichData value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithData(value);
			return this.NewSpine(mutatedLeaf);
		}
	
		/// <summary>Gets the unrooted representation of this object in the hierarchy.</summary>
		public FileSystemEntry FileSystemEntry {
			get { return this.greenNode; }
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public RootedFileSystemEntry With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>)) {
			this.ThrowIfDefault();
			var newGreenNode = this.greenNode.With(
				pathSegment: pathSegment,
				data: data);
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return new RootedFileSystemEntry(newGreenNode, newRoot);
		}
	
		public System.Collections.Generic.IReadOnlyList<FileSystemEntry.DiffGram> ChangesSince(RootedFileSystemEntry priorVersion) {
			this.ThrowIfDefault();
			return this.greenNode.ChangesSince(priorVersion.FileSystemEntry);
		}
		
		public RootedFileSystemFile ToFileSystemFile(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>)) {
			var newGreenNode = this.greenNode.ToFileSystemFile(
					attributes: attributes);
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return new RootedFileSystemFile(newGreenNode, newRoot);
		}
		
		public RootedFileSystemDirectory ToFileSystemDirectory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>>)) {
			var newGreenNode = this.greenNode.ToFileSystemDirectory(
					children: children.IsDefined ? (System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>)((ImmutableObjectGraph.Adapters.IImmutableCollectionAdapter<FileSystemEntry>)children.Value).UnderlyingCollection : default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>));
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return new RootedFileSystemDirectory(newGreenNode, newRoot);
		}
	
		public override bool Equals(object obj) {
			if (obj is RootedFileSystemEntry) {
				var other = (RootedFileSystemEntry)obj;
				return this.Equals(other);
			}
	
			return false;
		}
	
		public bool Equals(RootedFileSystemEntry other) {
			return this.greenNode == other.greenNode && this.root == other.root;
		}
	
		public override int GetHashCode() {
			return this.greenNode == null ? 0 : this.greenNode.GetHashCode();
		}
	
		private RootedFileSystemEntry NewSpine(FileSystemEntry leaf) {
			var newRoot = this.root.ReplaceDescendent(this.greenNode, leaf);
			return new RootedFileSystemEntry(leaf, newRoot);
		}
	
		/// <summary>Gets a value indicating whether this struct has not been initialized to represent an object.</summary>
		public bool IsDefault {
			get { return this.greenNode == null; }
		}
	
		/// <summary>Throws an exception if this struct does not have a backing FileSystemEntry.</summary>
		private void ThrowIfDefault() {
			if (this.greenNode == null) {
				throw new System.InvalidOperationException();
			}
		}
	}
	
	[System.Flags]
	public enum FileSystemEntryChangedProperties : uint {
		/// <summary>
		/// No change was made to the node.  It was either entirely added or removed. 
		/// </summary>
		None = 0x0,
	
		/// <summary>
		/// The type of the node was changed.
		/// </summary>
		Type = 0x1,
	
		/// <summary>
		/// The node's position within its parent's list of children changed.
		/// </summary>
		PositionUnderParent = 0x2,
		
		/// <summary>
		/// The node was removed and reappeared in a new position in the tree (with a different parent).
		/// </summary>
		Parent = 0x4,
	
		/// <summary>
		/// The PathSegment property was changed.
		/// </summary>
		PathSegment = 0x8,
	
		/// <summary>
		/// The Data property was changed.
		/// </summary>
		Data = 0x10,
	
		/// <summary>
		/// The Attributes property was changed.
		/// </summary>
		Attributes = 0x20,
	
		/// <summary>
		/// All flags in this enum.
		/// </summary>
		All = Type | PositionUnderParent | Parent | PathSegment | Data | Attributes,
	}
	
	public interface IFileSystemFile : IFileSystemEntry {
		System.Collections.Immutable.ImmutableHashSet<System.String> Attributes { get; }
	}
	
	public partial class FileSystemFile : FileSystemEntry, IFileSystemFile {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly FileSystemFile DefaultInstance = GetDefaultTemplate();
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Collections.Immutable.ImmutableHashSet<System.String> attributes;
	
		/// <summary>Initializes a new instance of the FileSystemFile class.</summary>
		protected FileSystemFile(
			System.UInt32 identity,
			System.String pathSegment,
			RichData data,
			System.Collections.Immutable.ImmutableHashSet<System.String> attributes,
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
			: base(
				identity: identity,
				pathSegment: pathSegment,
				data: data)
		{
			this.attributes = attributes;
			if (!skipValidation.Value) {
				this.Validate();
			}
		}
	
		public static FileSystemFile Create(
			System.String pathSegment,
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				pathSegment: Optional.For(pathSegment),
				data: Optional.For(data.GetValueOrDefault(DefaultInstance.Data)),
				attributes: Optional.For(attributes.GetValueOrDefault(DefaultInstance.Attributes)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public System.Collections.Immutable.ImmutableHashSet<System.String> Attributes {
			get { return this.attributes; }
		}
		
		/// <summary>Returns a new instance with the PathSegment property set to the specified value.</summary>
		public new FileSystemFile WithPathSegment(System.String value) {
			return (FileSystemFile)base.WithPathSegment(value);
		}
		
		/// <summary>Returns a new instance with the Data property set to the specified value.</summary>
		public new FileSystemFile WithData(RichData value) {
			return (FileSystemFile)base.WithData(value);
		}
		
		/// <summary>Returns a new instance with the Attributes property set to the specified value.</summary>
		public FileSystemFile WithAttributes(System.Collections.Immutable.ImmutableHashSet<System.String> value) {
			if (value == this.Attributes) {
				return this;
			}
		
			return this.With(attributes: Optional.For(value));
		}
		
		/// <summary>Replaces the elements of the Attributes collection with the specified collection.</summary>
		public FileSystemFile WithAttributes(params System.String[] values) {
			return this.With(attributes: this.Attributes.ResetContents(values));
		}
		
		/// <summary>Replaces the elements of the Attributes collection with the specified collection.</summary>
		public FileSystemFile WithAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			return this.With(attributes: this.Attributes.ResetContents(values));
		}
		
		/// <summary>Adds the specified elements from the Attributes collection.</summary>
		public FileSystemFile AddAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			return this.With(attributes: this.Attributes.AddRange(values));
		}
		
		/// <summary>Adds the specified elements from the Attributes collection.</summary>
		public FileSystemFile AddAttributes(params System.String[] values) {
			return this.With(attributes: this.Attributes.AddRange(values));
		}
		
		/// <summary>Adds the specified element from the Attributes collection.</summary>
		public FileSystemFile AddAttribute(System.String value) {
			return this.With(attributes: this.Attributes.Add(value));
		}
		
		/// <summary>Removes the specified elements from the Attributes collection.</summary>
		public FileSystemFile RemoveAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			return this.With(attributes: this.Attributes.RemoveRange(values));
		}
		
		/// <summary>Removes the specified elements from the Attributes collection.</summary>
		public FileSystemFile RemoveAttributes(params System.String[] values) {
			return this.With(attributes: this.Attributes.RemoveRange(values));
		}
		
		/// <summary>Removes the specified element from the Attributes collection.</summary>
		public FileSystemFile RemoveAttribute(System.String value) {
			return this.With(attributes: this.Attributes.Remove(value));
		}
		
		/// <summary>Clears all elements from the Attributes collection.</summary>
		public FileSystemFile RemoveAttributes() {
			return this.With(attributes: this.Attributes.Clear());
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected override FileSystemEntry WithCore(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>)) {
			return this.WithFactory(
				pathSegment: pathSegment,
				data: data);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public FileSystemFile With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>)) {
			return (FileSystemFile)this.WithCore(
				pathSegment: pathSegment,
				data: data,
				attributes: attributes);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected virtual FileSystemFile WithCore(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.UInt32>);
			return this.WithFactory(
				pathSegment: Optional.For(pathSegment.GetValueOrDefault(this.PathSegment)),
				data: Optional.For(data.GetValueOrDefault(this.Data)),
				attributes: Optional.For(attributes.GetValueOrDefault(this.Attributes)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private FileSystemFile WithFactory(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>),
			ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(pathSegment.IsDefined && pathSegment.Value != this.PathSegment) || 
				(data.IsDefined && data.Value != this.Data) || 
				(attributes.IsDefined && attributes.Value != this.Attributes)) {
				return new FileSystemFile(
					identity: identity.GetValueOrDefault(this.Identity),
					pathSegment: pathSegment.GetValueOrDefault(this.PathSegment),
					data: data.GetValueOrDefault(this.Data),
					attributes: attributes.GetValueOrDefault(this.Attributes));
			} else {
				return this;
			}
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated FileSystemFile whose fields are initialized with default values.</summary>
		private static FileSystemFile GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new FileSystemFile(
				default(System.UInt32),
				template.PathSegment,
				template.Data,
				template.Attributes,
				skipValidation: true);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.String PathSegment { get; set; }
	
			internal RichData Data { get; set; }
	
			internal System.Collections.Immutable.ImmutableHashSet<System.String> Attributes { get; set; }
		}
		
		public new RootedFileSystemFile WithRoot(FileSystemDirectory root) {
			var spine = root.GetSpine(this);
			if (spine.IsEmpty) {
				throw new System.ArgumentException("Root does not belong to the same tree.");
			}
		
			return new RootedFileSystemFile(this, root);
		}
		
		protected override FileSystemEntryChangedProperties DiffProperties(FileSystemEntry other) {
			var propertiesChanged = base.DiffProperties(other);
		
			var otherFileSystemFile = other as FileSystemFile;
			if (otherFileSystemFile != null) {
				if (this.Attributes != otherFileSystemFile.Attributes) {
					propertiesChanged |= FileSystemEntryChangedProperties.Attributes;
				}
			}
		
			return propertiesChanged;
		}
		
		internal static FileSystemFile CreateWithIdentity(
				System.String pathSegment,
				ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>),
				ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>),
				ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (!identity.IsDefined) {
				identity = NewIdentity();
			}
		
			return DefaultInstance.WithFactory(
					pathSegment: Optional.For(pathSegment),
					data: Optional.For(data.GetValueOrDefault(DefaultInstance.Data)),
					attributes: Optional.For(attributes.GetValueOrDefault(DefaultInstance.Attributes)),
					identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	}
	
	public partial struct RootedFileSystemFile : System.IEquatable<RootedFileSystemFile>, IRecursiveType {
		private readonly FileSystemFile greenNode;
	
		private readonly FileSystemDirectory root;
	
		internal RootedFileSystemFile(FileSystemFile fileSystemFile, FileSystemDirectory root) {
			this.greenNode = fileSystemFile;
			this.root = root;
		}
	
		public static implicit operator FileSystemFile(RootedFileSystemFile rooted) {
			return rooted.FileSystemFile;
		}
	
		public static bool operator ==(RootedFileSystemFile that, RootedFileSystemFile other) {
			return that.FileSystemFile == other.FileSystemFile
			    && that.Root.FileSystemDirectory == other.Root.FileSystemDirectory;
		}
	
		public static bool operator !=(RootedFileSystemFile that, RootedFileSystemFile other) {
			return !(that == other);
		}
	
		/// <summary>Gets the parent of this object in the hierarchy.</summary>
		public RootedFileSystemDirectory Parent {
			get {
				this.ThrowIfDefault();
				var greenParent = this.root.GetParent(this.FileSystemFile);
				return greenParent != null ? new RootedFileSystemDirectory(greenParent, this.root) : default(RootedFileSystemDirectory);
			}
		}
	
		public RootedFileSystemDirectory Root {
			get { return this.root != null ? this.root.AsRoot : default(RootedFileSystemDirectory); }
		}
	
		public uint Identity {
			get {
				this.ThrowIfDefault();
				return (uint)this.greenNode.Identity;
			}
		}
	
		public RootedFileSystemEntry AsFileSystemEntry {
			get { return this.greenNode != null ? new RootedFileSystemEntry((FileSystemEntry)this.greenNode, this.root) : default(RootedFileSystemEntry); }
		}
	
		public System.String PathSegment {
			get {
				this.ThrowIfDefault();
				return this.greenNode.PathSegment;
			}
		}
		
		/// <summary>Returns a new instance with the PathSegment property set to the specified value.</summary>
		public RootedFileSystemFile WithPathSegment(System.String value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithPathSegment(value);
			return this.NewSpine(mutatedLeaf);
		}
	
		public RichData Data {
			get {
				this.ThrowIfDefault();
				return this.greenNode.Data;
			}
		}
		
		/// <summary>Returns a new instance with the Data property set to the specified value.</summary>
		public RootedFileSystemFile WithData(RichData value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithData(value);
			return this.NewSpine(mutatedLeaf);
		}
	
		public System.Collections.Immutable.ImmutableHashSet<System.String> Attributes {
			get {
				this.ThrowIfDefault();
				return this.greenNode.Attributes;
			}
		}
		
		/// <summary>Returns a new instance with the Attributes property set to the specified value.</summary>
		public RootedFileSystemFile WithAttributes(System.Collections.Immutable.ImmutableHashSet<System.String> value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithAttributes(value);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Replaces the elements of the Attributes collection with the specified collection.</summary>
		public RootedFileSystemFile WithAttributes(params System.String[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithAttributes(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Replaces the elements of the Attributes collection with the specified collection.</summary>
		public RootedFileSystemFile WithAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithAttributes(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified elements from the Attributes collection.</summary>
		public RootedFileSystemFile AddAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddAttributes(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified elements from the Attributes collection.</summary>
		public RootedFileSystemFile AddAttributes(params System.String[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddAttributes(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified element from the Attributes collection.</summary>
		public RootedFileSystemFile AddAttribute(System.String value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddAttribute(value);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified elements from the Attributes collection.</summary>
		public RootedFileSystemFile RemoveAttributes(System.Collections.Generic.IEnumerable<System.String> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveAttributes(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified elements from the Attributes collection.</summary>
		public RootedFileSystemFile RemoveAttributes(params System.String[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveAttributes(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified element from the Attributes collection.</summary>
		public RootedFileSystemFile RemoveAttribute(System.String value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveAttribute(value);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Clears all elements from the Attributes collection.</summary>
		public RootedFileSystemFile RemoveAttributes() {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveAttributes();
			return this.NewSpine(mutatedLeaf);
		}
	
		/// <summary>Gets the unrooted representation of this object in the hierarchy.</summary>
		public FileSystemFile FileSystemFile {
			get { return this.greenNode; }
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public RootedFileSystemFile With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>)) {
			this.ThrowIfDefault();
			var newGreenNode = this.greenNode.With(
				pathSegment: pathSegment,
				data: data,
				attributes: attributes);
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return new RootedFileSystemFile(newGreenNode, newRoot);
		}
	
		public System.Collections.Generic.IReadOnlyList<FileSystemEntry.DiffGram> ChangesSince(RootedFileSystemFile priorVersion) {
			this.ThrowIfDefault();
			return this.greenNode.ChangesSince(priorVersion.FileSystemFile);
		}
		
		public RootedFileSystemDirectory ToFileSystemDirectory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>>)) {
			var newGreenNode = this.greenNode.ToFileSystemDirectory(
					children: children.IsDefined ? (System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>)((ImmutableObjectGraph.Adapters.IImmutableCollectionAdapter<FileSystemEntry>)children.Value).UnderlyingCollection : default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>));
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return new RootedFileSystemDirectory(newGreenNode, newRoot);
		}
	
		public override bool Equals(object obj) {
			if (obj is RootedFileSystemFile) {
				var other = (RootedFileSystemFile)obj;
				return this.Equals(other);
			}
	
			return false;
		}
	
		public bool Equals(RootedFileSystemFile other) {
			return this.greenNode == other.greenNode && this.root == other.root;
		}
	
		public override int GetHashCode() {
			return this.greenNode == null ? 0 : this.greenNode.GetHashCode();
		}
	
		private RootedFileSystemFile NewSpine(FileSystemFile leaf) {
			var newRoot = this.root.ReplaceDescendent(this.greenNode, leaf);
			return new RootedFileSystemFile(leaf, newRoot);
		}
	
		/// <summary>Gets a value indicating whether this struct has not been initialized to represent an object.</summary>
		public bool IsDefault {
			get { return this.greenNode == null; }
		}
	
		/// <summary>Throws an exception if this struct does not have a backing FileSystemFile.</summary>
		private void ThrowIfDefault() {
			if (this.greenNode == null) {
				throw new System.InvalidOperationException();
			}
		}
	}
	
	public interface IFileSystemDirectory : IFileSystemEntry {
		System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry> Children { get; }
	}
	
	public partial class FileSystemDirectory : FileSystemEntry, IFileSystemDirectory, System.Collections.Generic.IEnumerable<FileSystemEntry>, IRecursiveParentWithSortedChildren, IRecursiveParent<FileSystemEntry>, IRecursiveParentWithLookupTable<FileSystemEntry>, IRecursiveParentWithChildReplacement<FileSystemEntry> {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly FileSystemDirectory DefaultInstance = GetDefaultTemplate();
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry> children;
	
		/// <summary>Initializes a new instance of the FileSystemDirectory class.</summary>
		protected FileSystemDirectory(
			System.UInt32 identity,
			System.String pathSegment,
			RichData data,
			System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry> children,
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.UInt32>>> lookupTable = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.UInt32>>>),
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
			: base(
				identity: identity,
				pathSegment: pathSegment,
				data: data)
		{
			this.children = children;
			if (!skipValidation.Value) {
				this.Validate();
			}
			var lookupTableInitResult = RecursiveTypeExtensions.LookupTable<FileSystemEntry, FileSystemDirectory>.Initialize(this, lookupTable);
			this.lookupTable = lookupTableInitResult.LookupTable;
			this.inefficiencyLoad = lookupTableInitResult.InefficiencyLoad;
		}
	
		public static FileSystemDirectory Create(
			System.String pathSegment,
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				pathSegment: Optional.For(pathSegment),
				data: Optional.For(data.GetValueOrDefault(DefaultInstance.Data)),
				children: Optional.For(children.GetValueOrDefault(DefaultInstance.Children)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry> Children {
			get { return this.children; }
		}
		
		/// <summary>Returns a new instance with the PathSegment property set to the specified value.</summary>
		public new FileSystemDirectory WithPathSegment(System.String value) {
			return (FileSystemDirectory)base.WithPathSegment(value);
		}
		
		/// <summary>Returns a new instance with the Data property set to the specified value.</summary>
		public new FileSystemDirectory WithData(RichData value) {
			return (FileSystemDirectory)base.WithData(value);
		}
		
		/// <summary>Returns a new instance with the Children property set to the specified value.</summary>
		public FileSystemDirectory WithChildren(System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry> value) {
			if (value == this.Children) {
				return this;
			}
		
			return this.With(children: Optional.For(value));
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public FileSystemDirectory WithChildren(params FileSystemEntry[] values) {
			return this.With(children: this.Children.ResetContents(values));
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public FileSystemDirectory WithChildren(System.Collections.Generic.IEnumerable<FileSystemEntry> values) {
			return this.With(children: this.Children.ResetContents(values));
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public FileSystemDirectory AddChildren(System.Collections.Generic.IEnumerable<FileSystemEntry> values) {
			return this.With(children: this.Children.AddRange(values));
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public FileSystemDirectory AddChildren(params FileSystemEntry[] values) {
			return this.With(children: this.Children.AddRange(values));
		}
		
		/// <summary>Adds the specified element from the Children collection.</summary>
		public FileSystemDirectory AddChild(FileSystemEntry value) {
			return this.With(children: this.Children.Add(value));
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public FileSystemDirectory RemoveChildren(System.Collections.Generic.IEnumerable<FileSystemEntry> values) {
			return this.With(children: this.Children.RemoveRange(values.Select(v => this.SyncImmediateChildToCurrentVersion(v))));
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public FileSystemDirectory RemoveChildren(params FileSystemEntry[] values) {
			return this.With(children: this.Children.RemoveRange(values.Select(v => this.SyncImmediateChildToCurrentVersion(v))));
		}
		
		/// <summary>Removes the specified element from the Children collection.</summary>
		public FileSystemDirectory RemoveChild(FileSystemEntry value) {
			return this.With(children: this.Children.Remove(this.SyncImmediateChildToCurrentVersion(value)));
		}
		
		/// <summary>Clears all elements from the Children collection.</summary>
		public FileSystemDirectory RemoveChildren() {
			return this.With(children: this.Children.Clear());
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected override FileSystemEntry WithCore(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>)) {
			return this.WithFactory(
				pathSegment: pathSegment,
				data: data);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public FileSystemDirectory With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>)) {
			return (FileSystemDirectory)this.WithCore(
				pathSegment: pathSegment,
				data: data,
				children: children);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected virtual FileSystemDirectory WithCore(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.UInt32>);
			return this.WithFactory(
				pathSegment: Optional.For(pathSegment.GetValueOrDefault(this.PathSegment)),
				data: Optional.For(data.GetValueOrDefault(this.Data)),
				children: Optional.For(children.GetValueOrDefault(this.Children)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private FileSystemDirectory WithFactory(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>),
			ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(pathSegment.IsDefined && pathSegment.Value != this.PathSegment) || 
				(data.IsDefined && data.Value != this.Data) || 
				(children.IsDefined && children.Value != this.Children)) {
				var lookupTable = children.IsDefined && children.Value != this.Children ? default(Optional<System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.UInt32>>>) : Optional.For(this.lookupTable);
				return new FileSystemDirectory(
					identity: identity.GetValueOrDefault(this.Identity),
					pathSegment: pathSegment.GetValueOrDefault(this.PathSegment),
					data: data.GetValueOrDefault(this.Data),
					children: children.GetValueOrDefault(this.Children),
					lookupTable: lookupTable);
			} else {
				return this;
			}
		}
	
		public System.Collections.Generic.IEnumerator<FileSystemEntry> GetEnumerator() {
			return this.children.GetEnumerator();
		}
	
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
			return this.children.GetEnumerator();
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated FileSystemDirectory whose fields are initialized with default values.</summary>
		private static FileSystemDirectory GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new FileSystemDirectory(
				default(System.UInt32),
				template.PathSegment,
				template.Data,
				template.Children,
				skipValidation: true);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.String PathSegment { get; set; }
	
			internal RichData Data { get; set; }
	
			internal System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry> Children { get; set; }
		}
		
		public RootedFileSystemDirectory AsRoot {
			get { return new RootedFileSystemDirectory(this, this); }
		}
		
		public new RootedFileSystemDirectory WithRoot(FileSystemDirectory root) {
			var spine = root.GetSpine(this);
			if (spine.IsEmpty) {
				throw new System.ArgumentException("Root does not belong to the same tree.");
			}
		
			return new RootedFileSystemDirectory(this, root);
		}
		
		protected FileSystemEntry SyncImmediateChildToCurrentVersion(FileSystemEntry child) {
			FileSystemEntry currentValue;
			if (!this.TryFindImmediateChild(child.Identity, out currentValue)) {
				throw new System.ArgumentException();
			}
		
			return currentValue;
		}
		
		public FileSystemDirectory AddDescendent(FileSystemEntry value, FileSystemDirectory parent) {
			var spine = this.GetSpine(parent);
			var newParent = parent.AddChildren(value);
			var newSpine = System.Collections.Immutable.ImmutableStack.Create(value, newParent);
			return (FileSystemDirectory)this.ReplaceDescendent(spine, newSpine, spineIncludesDeletedElement: false).Peek();
		}
		
		public FileSystemDirectory RemoveDescendent(FileSystemEntry value) {
			var spine = this.GetSpine(value);
			var spineList = spine.ToList();
			var parent = (FileSystemDirectory)spineList[spineList.Count - 2];
			var newParent = parent.RemoveChildren(spineList[spineList.Count - 1]);
		
			var newSpine = System.Collections.Immutable.ImmutableStack.Create((FileSystemEntry)newParent);
			return (FileSystemDirectory)this.ReplaceDescendent(spine, newSpine, spineIncludesDeletedElement: true).Peek();
		}
		
		/// <summary>Replaces one node with a modified version of itself (same identity) among this node's descendents</summary>
		public FileSystemDirectory ReplaceDescendent(FileSystemEntry updatedNode) {
			var spine = this.GetSpine(updatedNode.Identity);
		
			if (spine.IsEmpty) {
				// The descendent was not found.
				throw new System.ArgumentException("Old value not found");
			}
		
			return (FileSystemDirectory)this.ReplaceDescendent(spine, System.Collections.Immutable.ImmutableStack.Create(updatedNode), spineIncludesDeletedElement: false).Peek();
		}
		
		/// <summary>Replaces one node with another node that may have a different identity.</summary>
		public FileSystemDirectory ReplaceDescendent(FileSystemEntry current, FileSystemEntry replacement) {
			var spine = this.GetSpine(current);
		
			if (spine.IsEmpty) {
				// The descendent was not found.
				throw new System.ArgumentException("Old value not found");
			}
		
			return (FileSystemDirectory)this.ReplaceDescendent(spine, System.Collections.Immutable.ImmutableStack.Create(replacement), spineIncludesDeletedElement: false).Peek();
		}
		
		
		private System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.UInt32>> lookupTable;
		
		private uint inefficiencyLoad;
		
		private System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.UInt32>> LookupTable {
			get {
				if (this.lookupTable == RecursiveTypeExtensions.LookupTable<FileSystemEntry, FileSystemDirectory>.LazySentinel) {
					this.lookupTable = RecursiveTypeExtensions.LookupTable<FileSystemEntry, FileSystemDirectory>.CreateLookupTable(this);
				}
		
				return this.lookupTable;
			}
		}
		
		uint IRecursiveParentWithLookupTable<FileSystemEntry>.InefficiencyLoad {
			get { return this.inefficiencyLoad; }
		}
		
		System.Collections.Generic.IReadOnlyCollection<FileSystemEntry> IRecursiveParentWithLookupTable<FileSystemEntry>.Children {
			get { return this.Children; }
		}
		
		System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.UInt32>> IRecursiveParentWithLookupTable<FileSystemEntry>.LookupTable {
			get { return this.LookupTable; }
		}
		
		public System.Collections.Immutable.ImmutableStack<FileSystemEntry> GetSpine(FileSystemEntry descendent) {
			return this.GetSpine<FileSystemDirectory, FileSystemEntry>(descendent);
		}
		
		public System.Collections.Immutable.ImmutableStack<FileSystemEntry> GetSpine(System.UInt32 identity) {
			return this.GetSpine<FileSystemDirectory, FileSystemEntry>(identity);
		}
		
		public FileSystemEntry Find(System.UInt32 identity)
		{
			return this.Find<FileSystemDirectory, FileSystemEntry>(identity);
		}
		
		public FileSystemDirectory GetParent(FileSystemEntry descendent) {
			return this.GetParent<FileSystemDirectory, FileSystemEntry>(descendent);
		}
		
		public ParentedRecursiveType<FileSystemDirectory, FileSystemEntry> GetParentedNode(System.UInt32 identity) {
			return this.GetParentedNode<FileSystemDirectory, FileSystemEntry>(identity);
		}
		
		IRecursiveParent<FileSystemEntry> IRecursiveParentWithChildReplacement<FileSystemEntry>.ReplaceChild(System.Collections.Immutable.ImmutableStack<FileSystemEntry> oldSpine, System.Collections.Immutable.ImmutableStack<FileSystemEntry> newSpine) {
			var newChildren = this.Children.Replace(oldSpine.Peek(), newSpine.Peek());
			var newSelf = this.WithChildren(newChildren);
		
			var lookupTableLazySentinel = RecursiveTypeExtensions.LookupTable<FileSystemEntry, FileSystemDirectory>.LazySentinel;
			if (newSelf.lookupTable == lookupTableLazySentinel && this.lookupTable != null && this.lookupTable != lookupTableLazySentinel) {
				// Our newly mutated self wants a lookup table. If we already have one we can use it,
				// but it needs to be fixed up given the newly rewritten spine through our descendents.
				newSelf.lookupTable = RecursiveTypeExtensions.LookupTable<FileSystemEntry, FileSystemDirectory>.Fixup(this, ImmutableDeque.Create(newSpine), ImmutableDeque.Create(oldSpine));
				RecursiveTypeExtensions.LookupTable<FileSystemEntry, FileSystemDirectory>.ValidateInternalIntegrityDebugOnly(newSelf);
			}
		
			return newSelf;
		}
		
		
		internal static FileSystemDirectory CreateWithIdentity(
				System.String pathSegment,
				ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>),
				ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>),
				ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (!identity.IsDefined) {
				identity = NewIdentity();
			}
		
			return DefaultInstance.WithFactory(
					pathSegment: Optional.For(pathSegment),
					data: Optional.For(data.GetValueOrDefault(DefaultInstance.Data)),
					children: Optional.For(children.GetValueOrDefault(DefaultInstance.Children)),
					identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		System.Collections.Generic.IEnumerable<IRecursiveType> IRecursiveParent.Children {
			get { return this.Children; }
		}
	
		System.Collections.Generic.IEnumerable<FileSystemEntry> IRecursiveParent<FileSystemEntry>.Children {
			get { return this.Children; }
		}
	
		ParentedRecursiveType<IRecursiveParent<IRecursiveType>, IRecursiveType> IRecursiveParent.GetParentedNode(System.UInt32 identity) {
			var parented = this.GetParentedNode(identity);
			return new ParentedRecursiveType<IRecursiveParent<IRecursiveType>, IRecursiveType>(parented.Value, parented.Parent);
		}
		int IRecursiveParentWithOrderedChildren.IndexOf(IRecursiveType value) {
			return this.Children.IndexOf((FileSystemEntry)value);
		}
		int IRecursiveParentWithSortedChildren.Compare(IRecursiveType first, IRecursiveType second) {
			return this.Children.KeyComparer.Compare((FileSystemEntry)first, (FileSystemEntry)second);
		}
	}
	
	public partial struct RootedFileSystemDirectory : System.IEquatable<RootedFileSystemDirectory>, IRecursiveParent<RootedFileSystemEntry> {
		private static readonly System.Func<RootedFileSystemEntry, FileSystemEntry> toUnrooted = r => r.FileSystemEntry;
		private static readonly System.Func<FileSystemEntry, FileSystemDirectory, RootedFileSystemEntry> toRooted = (u, r) => new RootedFileSystemEntry(u, r);
	
		private readonly FileSystemDirectory greenNode;
	
		private readonly FileSystemDirectory root;
		private Optional<ImmutableObjectGraph.Adapters.ImmutableSetRootAdapter<FileSystemEntry, RootedFileSystemEntry, FileSystemDirectory>> children;
	
		internal RootedFileSystemDirectory(FileSystemDirectory fileSystemDirectory, FileSystemDirectory root) {
			this.greenNode = fileSystemDirectory;
			this.root = root;
			this.children = default(Optional<ImmutableObjectGraph.Adapters.ImmutableSetRootAdapter<FileSystemEntry, RootedFileSystemEntry, FileSystemDirectory>>);
		}
	
		public static implicit operator FileSystemDirectory(RootedFileSystemDirectory rooted) {
			return rooted.FileSystemDirectory;
		}
	
		public static bool operator ==(RootedFileSystemDirectory that, RootedFileSystemDirectory other) {
			return that.FileSystemDirectory == other.FileSystemDirectory
			    && that.Root.FileSystemDirectory == other.Root.FileSystemDirectory;
		}
	
		public static bool operator !=(RootedFileSystemDirectory that, RootedFileSystemDirectory other) {
			return !(that == other);
		}
	
		/// <summary>Gets the parent of this object in the hierarchy.</summary>
		public RootedFileSystemDirectory Parent {
			get {
				this.ThrowIfDefault();
				var greenParent = this.root.GetParent(this.FileSystemDirectory);
				return greenParent != null ? new RootedFileSystemDirectory(greenParent, this.root) : default(RootedFileSystemDirectory);
			}
		}
	
		public RootedFileSystemDirectory Root {
			get { return this.root != null ? this.root.AsRoot : default(RootedFileSystemDirectory); }
		}
	
		public uint Identity {
			get {
				this.ThrowIfDefault();
				return (uint)this.greenNode.Identity;
			}
		}
	
		public RootedFileSystemEntry AsFileSystemEntry {
			get { return this.greenNode != null ? new RootedFileSystemEntry((FileSystemEntry)this.greenNode, this.root) : default(RootedFileSystemEntry); }
		}
	
		public bool IsRoot {
			get { return this.root == this.greenNode; }
		}
	
		public System.String PathSegment {
			get {
				this.ThrowIfDefault();
				return this.greenNode.PathSegment;
			}
		}
		
		/// <summary>Returns a new instance with the PathSegment property set to the specified value.</summary>
		public RootedFileSystemDirectory WithPathSegment(System.String value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithPathSegment(value);
			return this.NewSpine(mutatedLeaf);
		}
	
		public RichData Data {
			get {
				this.ThrowIfDefault();
				return this.greenNode.Data;
			}
		}
		
		/// <summary>Returns a new instance with the Data property set to the specified value.</summary>
		public RootedFileSystemDirectory WithData(RichData value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithData(value);
			return this.NewSpine(mutatedLeaf);
		}
	
		public System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry> Children {
			get {
				if (!this.children.IsDefined) {
					this.ThrowIfDefault();
					this.children = Optional.For(Adapter.Create(this.greenNode.Children, toRooted, toUnrooted, this.root));
				}
	
				return this.children.Value;
			}
		}
		
		/// <summary>Returns a new instance with the Children property set to the specified value.</summary>
		public RootedFileSystemDirectory WithChildren(System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry> value) {
			this.ThrowIfDefault();
			var adapter = (ImmutableObjectGraph.Adapters.IImmutableCollectionAdapter<FileSystemEntry>)value;
			var mutatedLeaf = this.greenNode.WithChildren(adapter.UnderlyingCollection);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public RootedFileSystemDirectory WithChildren(params RootedFileSystemEntry[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithChildren(values.Select(r => r.FileSystemEntry));
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public RootedFileSystemDirectory WithChildren(System.Collections.Generic.IEnumerable<RootedFileSystemEntry> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithChildren(values.Select(r => r.FileSystemEntry));
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory AddChildren(System.Collections.Generic.IEnumerable<RootedFileSystemEntry> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddChildren(values.Select(r => r.FileSystemEntry));
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory AddChildren(params RootedFileSystemEntry[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddChildren(values.Select(r => r.FileSystemEntry));
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified element from the Children collection.</summary>
		public ParentedRecursiveType<RootedFileSystemDirectory, RootedFileSystemEntry> AddChild(RootedFileSystemEntry value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddChild(value.FileSystemEntry);
			var newParent = this.NewSpine(mutatedLeaf);
			var newChild = new RootedFileSystemEntry(value.FileSystemEntry, newParent.Root.FileSystemDirectory);
			return new ParentedRecursiveType<RootedFileSystemDirectory, RootedFileSystemEntry>(newChild, newParent);
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChildren(System.Collections.Generic.IEnumerable<RootedFileSystemEntry> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChildren(values.Select(r => r.FileSystemEntry));
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChildren(params RootedFileSystemEntry[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChildren(values.Select(r => r.FileSystemEntry));
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified element from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChild(RootedFileSystemEntry value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChild(value.FileSystemEntry);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public RootedFileSystemDirectory WithChildren(params FileSystemEntry[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithChildren(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public RootedFileSystemDirectory WithChildren(System.Collections.Generic.IEnumerable<FileSystemEntry> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.WithChildren(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory AddChildren(System.Collections.Generic.IEnumerable<FileSystemEntry> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddChildren(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory AddChildren(params FileSystemEntry[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddChildren(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Adds the specified element from the Children collection.</summary>
		public ParentedRecursiveType<RootedFileSystemDirectory, RootedFileSystemEntry> AddChild(FileSystemEntry value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.AddChild(value);
			var newParent = this.NewSpine(mutatedLeaf);
			var newChild = new RootedFileSystemEntry(value, newParent.Root.FileSystemDirectory);
			return new ParentedRecursiveType<RootedFileSystemDirectory, RootedFileSystemEntry>(newChild, newParent);
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChildren(System.Collections.Generic.IEnumerable<FileSystemEntry> values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChildren(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChildren(params FileSystemEntry[] values) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChildren(values);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Removes the specified element from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChild(FileSystemEntry value) {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChild(value);
			return this.NewSpine(mutatedLeaf);
		}
		
		/// <summary>Clears all elements from the Children collection.</summary>
		public RootedFileSystemDirectory RemoveChildren() {
			this.ThrowIfDefault();
			var mutatedLeaf = this.greenNode.RemoveChildren();
			return this.NewSpine(mutatedLeaf);
		}
	
		/// <summary>Gets the unrooted representation of this object in the hierarchy.</summary>
		public FileSystemDirectory FileSystemDirectory {
			get { return this.greenNode; }
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public RootedFileSystemDirectory With(
			ImmutableObjectGraph.Optional<System.String> pathSegment = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>>)) {
			this.ThrowIfDefault();
			var newGreenNode = this.greenNode.With(
				pathSegment: pathSegment,
				data: data,
				children: children.IsDefined ? (System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>)((ImmutableObjectGraph.Adapters.IImmutableCollectionAdapter<FileSystemEntry>)children.Value).UnderlyingCollection : default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>));
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return new RootedFileSystemDirectory(newGreenNode, newRoot);
		}
	
		public static RootedFileSystemDirectory Create(
			System.String pathSegment,
			ImmutableObjectGraph.Optional<RichData> data = default(ImmutableObjectGraph.Optional<RichData>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.IImmutableSet<RootedFileSystemEntry>>)) {
			var greenNode = FileSystemDirectory.Create(
				pathSegment: pathSegment,
				data: data,
				children: children.IsDefined ? (System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>)((ImmutableObjectGraph.Adapters.IImmutableCollectionAdapter<FileSystemEntry>)children.Value).UnderlyingCollection : default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableSortedSet<FileSystemEntry>>));
			return greenNode.AsRoot;
		}
	
		public RootedFileSystemEntry Find(System.UInt32 identity) {
			this.ThrowIfDefault();
			return new RootedFileSystemEntry(this.greenNode.Find(identity), this.root);
		}
	
		public bool TryFind(System.UInt32 identity, out RootedFileSystemEntry value) {
			this.ThrowIfDefault();
			FileSystemEntry greenValue;
			if (this.greenNode.TryFind(identity, out greenValue)) {
				value = new RootedFileSystemEntry(greenValue, this.root);
				return true;
			}
	
			value = default(RootedFileSystemEntry);
			return false;
		}
	
		public System.Collections.Generic.IEnumerator<RootedFileSystemEntry> GetEnumerator() {
			return this.Children.GetEnumerator();
		}
	
		public System.Collections.Generic.IReadOnlyList<FileSystemEntry.DiffGram> ChangesSince(RootedFileSystemDirectory priorVersion) {
			this.ThrowIfDefault();
			return this.greenNode.ChangesSince(priorVersion.FileSystemDirectory);
		}
		
		public RootedFileSystemFile ToFileSystemFile(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>> attributes = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableHashSet<System.String>>)) {
			var newGreenNode = this.greenNode.ToFileSystemFile(
					attributes: attributes);
			var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
			return new RootedFileSystemFile(newGreenNode, newRoot);
		}
	
		public override bool Equals(object obj) {
			if (obj is RootedFileSystemDirectory) {
				var other = (RootedFileSystemDirectory)obj;
				return this.Equals(other);
			}
	
			return false;
		}
	
		public bool Equals(RootedFileSystemDirectory other) {
			return this.greenNode == other.greenNode && this.root == other.root;
		}
	
		public override int GetHashCode() {
			return this.greenNode == null ? 0 : this.greenNode.GetHashCode();
		}
	
		private RootedFileSystemDirectory NewSpine(FileSystemDirectory leaf) {
			var newRoot = this.root.ReplaceDescendent(this.greenNode, leaf);
			return new RootedFileSystemDirectory(leaf, newRoot);
		}
	
		/// <summary>Gets a value indicating whether this struct has not been initialized to represent an object.</summary>
		public bool IsDefault {
			get { return this.greenNode == null; }
		}
	
		/// <summary>Throws an exception if this struct does not have a backing FileSystemDirectory.</summary>
		private void ThrowIfDefault() {
			if (this.greenNode == null) {
				throw new System.InvalidOperationException();
			}
		}
	
		System.Collections.Generic.IEnumerable<IRecursiveType> IRecursiveParent.Children {
			get {
				this.ThrowIfDefault();
				return this.Children.Cast<IRecursiveType>();
			}
		}
		
		System.Collections.Generic.IEnumerable<RootedFileSystemEntry> IRecursiveParent<RootedFileSystemEntry>.Children {
			get {
				this.ThrowIfDefault();
				var that = this;
				return this.greenNode.Children.Select(c => new RootedFileSystemEntry(c, that.root));
			}
		}
	
		ParentedRecursiveType<IRecursiveParent<IRecursiveType>, IRecursiveType> IRecursiveParent.GetParentedNode(System.UInt32 identity) {
			this.ThrowIfDefault();
			var result = this.greenNode.GetParentedNode(identity);
			return new ParentedRecursiveType<IRecursiveParent<IRecursiveType>, IRecursiveType>(result.Value, result.Parent);
		}
	}
	
	public interface IRichData {
		System.Int32 SomeCoolProperty { get; }
	}
	
	public partial class RichData : IRichData {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly RichData DefaultInstance = GetDefaultTemplate();
		
		/// <summary>The last identity assigned to a created instance.</summary>
		private static int lastIdentityProduced;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Int32 someCoolProperty;
	
		private readonly System.UInt32 identity;
	
		/// <summary>Initializes a new instance of the RichData class.</summary>
		protected RichData(
			System.UInt32 identity,
			System.Int32 someCoolProperty,
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
		{
			this.identity = identity;
			this.someCoolProperty = someCoolProperty;
			if (!skipValidation.Value) {
				this.Validate();
			}
		}
	
		public static RichData Create(
			ImmutableObjectGraph.Optional<System.Int32> someCoolProperty = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				someCoolProperty: Optional.For(someCoolProperty.GetValueOrDefault(DefaultInstance.SomeCoolProperty)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public System.Int32 SomeCoolProperty {
			get { return this.someCoolProperty; }
		}
		
		/// <summary>Returns a new instance with the SomeCoolProperty property set to the specified value.</summary>
		public RichData WithSomeCoolProperty(System.Int32 value) {
			if (value == this.SomeCoolProperty) {
				return this;
			}
		
			return this.With(someCoolProperty: Optional.For(value));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public RichData With(
			ImmutableObjectGraph.Optional<System.Int32> someCoolProperty = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			return (RichData)this.WithCore(
				someCoolProperty: someCoolProperty);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected virtual RichData WithCore(
			ImmutableObjectGraph.Optional<System.Int32> someCoolProperty = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.UInt32>);
			return this.WithFactory(
				someCoolProperty: Optional.For(someCoolProperty.GetValueOrDefault(this.SomeCoolProperty)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private RichData WithFactory(
			ImmutableObjectGraph.Optional<System.Int32> someCoolProperty = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(someCoolProperty.IsDefined && someCoolProperty.Value != this.SomeCoolProperty)) {
				return new RichData(
					identity: identity.GetValueOrDefault(this.Identity),
					someCoolProperty: someCoolProperty.GetValueOrDefault(this.SomeCoolProperty));
			} else {
				return this;
			}
		}
	
		protected internal uint Identity {
			get { return (uint)this.identity; }
		}
	
		/// <summary>Returns a unique identity that may be assigned to a newly created instance.</summary>
		protected static System.UInt32 NewIdentity() {
			return (System.UInt32)System.Threading.Interlocked.Increment(ref lastIdentityProduced);
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated RichData whose fields are initialized with default values.</summary>
		private static RichData GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new RichData(
				default(System.UInt32),
				template.SomeCoolProperty,
				skipValidation: true);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.Int32 SomeCoolProperty { get; set; }
		}
	}
}


