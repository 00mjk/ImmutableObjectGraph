<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ Import Namespace="System.Reflection" #>
<#@ Import Namespace="System.Collections.Generic" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace <#= this.Namespace #> {
	using System.Diagnostics;

<#
	this.PushIndent("\t");
	var templateTypes = DiscoverTemplateTypes(this.TemplateType);
	foreach(var templateType in templateTypes) {
#>

public partial class <#= templateType.Name #> {
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static readonly <#= templateType.Name #> DefaultInstance = GetDefaultTemplate();
<#
	var fields = templateType.GetFields(BindingFlags.NonPublic | BindingFlags.Instance);
	foreach(var field in fields) {
#>

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly <#= GetTypeName(field.FieldType) #> <#= CamelCase(field.Name) #>;
<#
	}
#>

	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	private <#= templateType.Name #>()
	{
	}

	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	private <#= templateType.Name #>(<#
	bool firstInSequence = true;
	foreach(var field in fields) {
		if (!firstInSequence) { Write(", "); }
		Write(GetTypeName(field.FieldType));
		Write(" ");
		Write(CamelCase(field.Name));
		firstInSequence = false;
	}
#>)
	{
<#
	foreach(var field in fields) {
#>
		this.<#= CamelCase(field.Name) #> = <#= CamelCase(field.Name) #>;
<#
	}
#>
		this.Validate();
	}

	public static <#= templateType.Name #> Create(<#
		firstInSequence = true;
		this.PushIndent("\t\t");

		// Value parameters
		foreach(var field in fields) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write(GetOptionalTypeName(field.FieldType));
			Write(" ");
			Write(CamelCase(field.Name));
			Write(" = default(" + GetOptionalTypeName(field.FieldType) + ")");
			firstInSequence = false;
		}

		this.PopIndent();
#>) {
		return DefaultInstance.With(<#
		firstInSequence = true;
		this.PushIndent("\t\t\t");

		// Value parameters
		foreach(var field in fields) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			#><#=CamelCase(field.Name)#>.IsDefined ? <#=CamelCase(field.Name)#> : ImmutableObjectGraph.Optional.For(DefaultInstance.<#=CamelCase(field.Name)#>)<#
			firstInSequence = false;
		}

		this.PopIndent();
#>);
	}
<#
	foreach(var field in fields) {
#>

	public <#= GetTypeName(field.FieldType) #> <#= PascalCase(field.Name) #> {
		get { return this.<#= CamelCase(field.Name) #>; }
	}

	public <#= templateType.Name #> With<#= PascalCase(field.Name) #>(<#= GetTypeName(field.FieldType) #> value) {
		if (value == this.<#= PascalCase(field.Name) #>) {
			return this;
		}

		return new <#= templateType.Name #>(<#
	firstInSequence = true;
	foreach(var field2 in fields) {
		if (!firstInSequence) { Write(", "); }
		if (field == field2) {
			Write("value");
		} else {
			Write("this." + PascalCase(field2.Name));
		}

		firstInSequence = false;
	}
#>);
	}
<#
	}
#>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public <#= templateType.Name #> With(<#
		firstInSequence = true;
		this.PushIndent("\t\t");

		// Value parameters
		foreach(var field in fields) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write(GetOptionalTypeName(field.FieldType));
			Write(" ");
			Write(CamelCase(field.Name));
			Write(" = default(" + GetOptionalTypeName(field.FieldType) + ")");
			firstInSequence = false;
		}

		this.PopIndent();
#>) {
		if (<#
			firstInSequence = true;
			foreach(var field in fields) {
				if (!firstInSequence) { Write(" || "); }
				WriteLine("");
#>			(<#= CamelCase(field.Name) #>.IsDefined && <#= CamelCase(field.Name) #>.Value != this.<#= PascalCase(field.Name) #>)<#
				firstInSequence = false;
			}
	#>) {
			return new <#= templateType.Name #>(<#
				firstInSequence = true;
				foreach(var field in fields) {
					if (!firstInSequence) { Write(","); }
					WriteLine("");
	#>				<#= CamelCase(field.Name) #>.IsDefined ? <#= CamelCase(field.Name) #>.Value : this.<#= PascalCase(field.Name) #><#
					firstInSequence = false;
				}
		#>);
		} else {
			return this;
		}
	}

	public Builder ToBuilder() {
		return new Builder(this);
	}

	/// <summary>Normalizes and/or validates all properties on this object.</summary>
	/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
	partial void Validate();

	/// <summary>Provides defaults for fields.</summary>
	/// <param name="template">The struct to set default values on.</param>
	static partial void CreateDefaultTemplate(ref Template template);

	/// <summary>Returns a newly instantiated <#= templateType.Name #> whose fields are initialized with default values.</summary>
	private static <#= templateType.Name #> GetDefaultTemplate() {
		var template = new Template();
		CreateDefaultTemplate(ref template);
		return new <#= templateType.Name #>(<#
		firstInSequence = true;
		this.PushIndent("\t\t\t");

		// Value parameters
		foreach(var field in fields) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write("template.");
			Write(PascalCase(field.Name));
			firstInSequence = false;
		}

		this.PopIndent();
#>);
	}

	public partial class Builder {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private <#= templateType.Name #> immutable;
<#		foreach(var field in fields) { #>

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private <#= GetBuilderFieldTypeName(field.FieldType, templateTypes) #> <#= CamelCase(field.Name) #>;
<#		} #>

		internal Builder(<#= templateType.Name #> immutable) {
			this.immutable = immutable;

<#
			foreach(var field in fields.Where(f => !templateTypes.Contains(f.FieldType))) {
#>
			this.<#= CamelCase(field.Name) #> = immutable.<#= PascalCase(field.Name) #>;
<#			} #>
		}
<#		foreach(var field in fields) { #>

		public <#= GetBuilderPropertyTypeName(field.FieldType, templateTypes) #> <#= PascalCase(field.Name) #> {
			get {
<# if (templateTypes.Contains(field.FieldType)) { #>
				if (!this.<#= CamelCase(field.Name) #>.IsDefined) {
					this.<#= CamelCase(field.Name) #> = this.immutable.<#= CamelCase(field.Name) #>.ToBuilder();
				}

				return this.<#= CamelCase(field.Name) #>.Value;
<# } else { #>
				return this.<#= CamelCase(field.Name) #>;
<# } #>
			}

			set {
				this.<#= CamelCase(field.Name) #> = value;
			}
		}
<#		} #>

		public <#= templateType.Name #> ToImmutable() {
<#			foreach(var templateField in fields.Where(f => templateTypes.Contains(f.FieldType))) { #>
			var <#= CamelCase(templateField.Name) #> = this.<#= CamelCase(templateField.Name) #>.IsDefined ? (this.<#= CamelCase(templateField.Name) #>.Value != null ? this.<#= CamelCase(templateField.Name) #>.Value.ToImmutable() : null) : this.immutable.<#= CamelCase(templateField.Name) #>;
<#			} #>
			return this.immutable = this.immutable.With(<#
			firstInSequence = true;
			foreach(var field in fields) {
				if (!firstInSequence) { Write(","); }
				WriteLine("");
				string prefix = templateTypes.Contains(field.FieldType) ? "" : "this."; #>
				ImmutableObjectGraph.Optional.For(<#= prefix + CamelCase(field.Name) #>)<#
				firstInSequence = false;
			} #>
);
		}
	}

	/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
	private struct Template {<#
	foreach(var field in fields) {
#>

		internal <#= GetTypeName(field.FieldType) #> <#= PascalCase(field.Name) #> { get; set; }
<#
	}
#>
	}
}
<# } // looping over all template types

	this.PopIndent();
#>
}
<#+
	public Type TemplateType { get; set; }

	public string Namespace { get; set; }

	public bool UseClassCollectionType { get; set; }

	protected static string PascalCase(string name) {
		return name.Substring(0,1).ToUpperInvariant() + name.Substring(1);
	}

	protected static string CamelCase(string name) {
		return name.Substring(0,1).ToLowerInvariant() + name.Substring(1);
	}

	protected static HashSet<Type> DiscoverTemplateTypes(Type rootType) {
		var types = new HashSet<Type>();
		var pendingTypes = new Queue<Type>();
		pendingTypes.Enqueue(rootType);
		while(pendingTypes.Count > 0)
		{
			var type = pendingTypes.Dequeue();
			if (types.Add(type)) {
				foreach(var field in type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic)) {
					var memberType = field.FieldType;
					if (memberType.IsArray) {
						memberType = memberType.GetElementType();
					}

					if (memberType.DeclaringType == type.DeclaringType) {
						pendingTypes.Enqueue(memberType);
					}
				}
			}
		}

		return types;
	}
	
	protected string GetBuilderPropertyTypeName(Type type, HashSet<Type> templateTypes) {
		if (templateTypes.Contains(type)) {
			return type.Name + ".Builder";
		} else {
			return GetTypeName(type);
		}
	}

	protected string GetBuilderFieldTypeName(Type type, HashSet<Type> templateTypes) {
		if (templateTypes.Contains(type)) {
			return "ImmutableObjectGraph.Optional<" + type.Name + ".Builder>";
		} else {
			return GetTypeName(type);
		}
	}

	protected string GetTypeName(Type type) {
		bool collection = false;
		if (type.IsArray) {
			type = type.GetElementType();
			collection = true;
		}

		string typeName = 
			type.DeclaringType == this.TemplateType.DeclaringType
			? type.Name
			: type.FullName;

		if (collection) {
			if (UseClassCollectionType)
				typeName = "System.Collections.Immutable.ImmutableList<" + typeName + ">";
			else
				typeName = "System.Collections.Immutable.IImmutableList<" + typeName + ">";
		}

		return typeName;
	}

	protected string GetOptionalTypeName(Type type)
	{
		return "ImmutableObjectGraph.Optional<" + GetTypeName(type) + ">";
	}

#>
