<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="$(ProjectDir)..\packages\Microsoft.Bcl.Immutable.1.0.8-beta\lib\net45\System.Collections.Immutable.dll" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="System.Collections.Immutable" #>
<#@ import namespace="System.Linq" #>
<#@ Import Namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace <#= this.Namespace #> {
	using System.Diagnostics;
	using ImmutableObjectGraph;

<#
	this.PushIndent("\t");
	var templateTypes = DiscoverTemplateTypes(this.TemplateType);
	foreach(var templateType in templateTypes) {
#>

public partial class <#= templateType.Name #> {
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static readonly <#= templateType.Name #> DefaultInstance = GetDefaultTemplate();
<#
	var fields = templateType.GetFields(BindingFlags.NonPublic | BindingFlags.Instance);
	foreach(var field in fields) {
#>

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly <#= GetTypeName(field.FieldType) #> <#= CamelCase(field.Name) #>;
<#
	}
#>

	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	private <#= templateType.Name #>()
	{
	}

	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	private <#= templateType.Name #>(<#
	bool firstInSequence = true;
	foreach(var field in fields) {
		if (!firstInSequence) { Write(", "); }
		Write(GetTypeName(field.FieldType));
		Write(" ");
		Write(CamelCase(field.Name));
		firstInSequence = false;
	}
#>)
	{
<#
	foreach(var field in fields) {
#>
		this.<#= CamelCase(field.Name) #> = <#= CamelCase(field.Name) #>;
<#
	}
#>
		this.Validate();
	}

	public static <#= templateType.Name #> Create(<#
		firstInSequence = true;
		this.PushIndent("\t\t");

		// Value parameters
		foreach(var field in fields) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write(GetOptionalTypeName(field.FieldType));
			Write(" ");
			Write(CamelCase(field.Name));
			Write(" = default(" + GetOptionalTypeName(field.FieldType) + ")");
			firstInSequence = false;
		}

		this.PopIndent();
#>) {
		return DefaultInstance.With(<#
		firstInSequence = true;
		this.PushIndent("\t\t\t");

		// Value parameters
		foreach(var field in fields) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			#><#=CamelCase(field.Name)#>.IsDefined ? <#=CamelCase(field.Name)#> : ImmutableObjectGraph.Optional.For(DefaultInstance.<#=CamelCase(field.Name)#>)<#
			firstInSequence = false;
		}

		this.PopIndent();
#>);
	}
<#
	foreach(var field in fields) {
#>

	public <#= GetTypeName(field.FieldType) #> <#= PascalCase(field.Name) #> {
		get { return this.<#= CamelCase(field.Name) #>; }
	}

	/// <summary>Returns a new instance with the <#= PascalCase(field.Name) #> property set to the specified value.</summary>
	public <#= templateType.Name #> With<#= PascalCase(field.Name) #>(<#= GetTypeName(field.FieldType) #> value) {
		if (value == this.<#= PascalCase(field.Name) #>) {
			return this;
		}

		return new <#= templateType.Name #>(<#
	firstInSequence = true;
	foreach(var field2 in fields) {
		if (!firstInSequence) { Write(", "); }
		if (field == field2) {
			Write("value");
		} else {
			Write("this." + PascalCase(field2.Name));
		}

		firstInSequence = false;
	}
#>);
	}
<#
	Type elementType;
	if (TryGetCollectionElementType(field.FieldType, out elementType)) { #>

	/// <summary>Replaces the elements of the <#= PascalCase(field.Name) #> collection with the specified collection.</summary>
	public <#= templateType.Name #> With<#= PascalCase(field.Name) #>(params <#= GetTypeName(elementType) #>[] values) {
		return new <#= templateType.Name #>(<#
	firstInSequence = true;
	foreach(var field2 in fields) {
		if (!firstInSequence) { Write(", "); }
		if (field == field2) {
			#>this.<#=PascalCase(field2.Name)#>.ResetContents(values)<#
		} else {
			Write("this." + PascalCase(field2.Name));
		}

		firstInSequence = false;
	}
#>);
	}

	/// <summary>Replaces the elements of the <#= PascalCase(field.Name) #> collection with the specified collection.</summary>
	public <#= templateType.Name #> With<#= PascalCase(field.Name) #>(System.Collections.Generic.IEnumerable<<#= GetTypeName(elementType) #>> values) {
		return new <#= templateType.Name #>(<#
	firstInSequence = true;
	foreach(var field2 in fields) {
		if (!firstInSequence) { Write(", "); }
		if (field == field2) {
			#>this.<#=PascalCase(field2.Name)#>.ResetContents(values)<#
		} else {
			Write("this." + PascalCase(field2.Name));
		}

		firstInSequence = false;
	}
#>);
	}

	/// <summary>Adds the specified elements from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Add<#= PascalCase(field.Name) #>(System.Collections.Generic.IEnumerable<<#= GetTypeName(elementType) #>> values) {
		return new <#= templateType.Name #>(<#
	firstInSequence = true;
	foreach(var field2 in fields) {
		if (!firstInSequence) { Write(", "); }
		if (field == field2) {
			#>this.<#=PascalCase(field2.Name)#>.AddRange(values)<#
		} else {
			Write("this." + PascalCase(field2.Name));
		}

		firstInSequence = false;
	}
#>);
	}

	/// <summary>Adds the specified elements from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Add<#= PascalCase(field.Name) #>(params <#= GetTypeName(elementType) #>[] values) {
		return new <#= templateType.Name #>(<#
	firstInSequence = true;
	foreach(var field2 in fields) {
		if (!firstInSequence) { Write(", "); }
		if (field == field2) {
			#>this.<#=PascalCase(field2.Name)#>.AddRange(values)<#
		} else {
			Write("this." + PascalCase(field2.Name));
		}

		firstInSequence = false;
	}
#>);
	}

	/// <summary>Adds the specified element from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Add<#= PascalCase(field.Name) #>(<#= GetTypeName(elementType) #> value) {
		return new <#= templateType.Name #>(<#
	firstInSequence = true;
	foreach(var field2 in fields) {
		if (!firstInSequence) { Write(", "); }
		if (field == field2) {
			#>this.<#=PascalCase(field2.Name)#>.Add(value)<#
		} else {
			Write("this." + PascalCase(field2.Name));
		}

		firstInSequence = false;
	}
#>);
	}

	/// <summary>Removes the specified elements from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Remove<#= PascalCase(field.Name) #>(System.Collections.Generic.IEnumerable<<#= GetTypeName(elementType) #>> values) {
		return new <#= templateType.Name #>(<#
	firstInSequence = true;
	foreach(var field2 in fields) {
		if (!firstInSequence) { Write(", "); }
		if (field == field2) {
			#>this.<#=PascalCase(field2.Name)#>.RemoveRange(values)<#
		} else {
			Write("this." + PascalCase(field2.Name));
		}

		firstInSequence = false;
	}
#>);
	}

	/// <summary>Removes the specified elements from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Remove<#= PascalCase(field.Name) #>(params <#= GetTypeName(elementType) #>[] values) {
		return new <#= templateType.Name #>(<#
	firstInSequence = true;
	foreach(var field2 in fields) {
		if (!firstInSequence) { Write(", "); }
		if (field == field2) {
			#>this.<#=PascalCase(field2.Name)#>.RemoveRange(values)<#
		} else {
			Write("this." + PascalCase(field2.Name));
		}

		firstInSequence = false;
	}
#>);
	}

	/// <summary>Removes the specified element from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Remove<#= PascalCase(field.Name) #>(<#= GetTypeName(elementType) #> value) {
		return new <#= templateType.Name #>(<#
	firstInSequence = true;
	foreach(var field2 in fields) {
		if (!firstInSequence) { Write(", "); }
		if (field == field2) {
			#>this.<#=PascalCase(field2.Name)#>.Remove(value)<#
		} else {
			Write("this." + PascalCase(field2.Name));
		}

		firstInSequence = false;
	}
#>);
	}

	/// <summary>Clears all elements from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Clear<#= PascalCase(field.Name) #>() {
		return new <#= templateType.Name #>(<#
	firstInSequence = true;
	foreach(var field2 in fields) {
		if (!firstInSequence) { Write(", "); }
		if (field == field2) {
			#>this.<#=PascalCase(field2.Name)#>.Clear()<#
		} else {
			Write("this." + PascalCase(field2.Name));
		}

		firstInSequence = false;
	}
#>);
	}
	<#}
	}
#>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public <#= templateType.Name #> With(<#
		firstInSequence = true;
		this.PushIndent("\t\t");

		// Value parameters
		foreach(var field in fields) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write(GetOptionalTypeName(field.FieldType));
			Write(" ");
			Write(CamelCase(field.Name));
			Write(" = default(" + GetOptionalTypeName(field.FieldType) + ")");
			firstInSequence = false;
		}

		this.PopIndent();
#>) {
		if (<#
			firstInSequence = true;
			foreach(var field in fields) {
				if (!firstInSequence) { Write(" || "); }
				WriteLine("");
#>			(<#= CamelCase(field.Name) #>.IsDefined && <#= CamelCase(field.Name) #>.Value != this.<#= PascalCase(field.Name) #>)<#
				firstInSequence = false;
			}
	#>) {
			return new <#= templateType.Name #>(<#
				firstInSequence = true;
				foreach(var field in fields) {
					if (!firstInSequence) { Write(","); }
					WriteLine("");
	#>				<#= CamelCase(field.Name) #>.IsDefined ? <#= CamelCase(field.Name) #>.Value : this.<#= PascalCase(field.Name) #><#
					firstInSequence = false;
				}
		#>);
		} else {
			return this;
		}
	}

	public Builder ToBuilder() {
		return new Builder(this);
	}

	/// <summary>Normalizes and/or validates all properties on this object.</summary>
	/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
	partial void Validate();

	/// <summary>Provides defaults for fields.</summary>
	/// <param name="template">The struct to set default values on.</param>
	static partial void CreateDefaultTemplate(ref Template template);

	/// <summary>Returns a newly instantiated <#= templateType.Name #> whose fields are initialized with default values.</summary>
	private static <#= templateType.Name #> GetDefaultTemplate() {
		var template = new Template();
		CreateDefaultTemplate(ref template);
		return new <#= templateType.Name #>(<#
		firstInSequence = true;
		this.PushIndent("\t\t\t");

		// Value parameters
		foreach(var field in fields) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write("template.");
			Write(PascalCase(field.Name));
			firstInSequence = false;
		}

		this.PopIndent();
#>);
	}

	public partial class Builder {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private <#= templateType.Name #> immutable;
<#		foreach(var field in fields) { #>

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private <#= GetBuilderFieldTypeName(field.FieldType, templateTypes) #> <#= CamelCase(field.Name) #>;
<#		} #>

		internal Builder(<#= templateType.Name #> immutable) {
			this.immutable = immutable;

<#
			foreach(var field in fields.Where(f => !templateTypes.Contains(f.FieldType) && !IsCollectionType(f.FieldType))) {
#>
			this.<#= CamelCase(field.Name) #> = immutable.<#= PascalCase(field.Name) #>;
<#			} #>
		}
<#		foreach(var field in fields) { #>

		public <#= GetBuilderPropertyTypeName(field.FieldType, templateTypes) #> <#= PascalCase(field.Name) #> {
			get {
<# if (templateTypes.Contains(field.FieldType) || IsCollectionType(field.FieldType)) { #>
				if (!this.<#= CamelCase(field.Name) #>.IsDefined) {
					this.<#= CamelCase(field.Name) #> = this.immutable.<#= CamelCase(field.Name) #> != null ? this.immutable.<#= CamelCase(field.Name) #>.ToBuilder() : null;
				}

				return this.<#= CamelCase(field.Name) #>.Value;
<# } else { #>
				return this.<#= CamelCase(field.Name) #>;
<# } #>
			}

			set {
				this.<#= CamelCase(field.Name) #> = value;
			}
		}
<#		} #>

		public <#= templateType.Name #> ToImmutable() {
<#			foreach(var templateField in fields.Where(f => templateTypes.Contains(f.FieldType) || IsCollectionType(f.FieldType))) { #>
			var <#= CamelCase(templateField.Name) #> = this.<#= CamelCase(templateField.Name) #>.IsDefined ? (this.<#= CamelCase(templateField.Name) #>.Value != null ? this.<#= CamelCase(templateField.Name) #>.Value.ToImmutable() : null) : this.immutable.<#= CamelCase(templateField.Name) #>;
<#			} #>
			return this.immutable = this.immutable.With(<#
			firstInSequence = true;
			foreach(var field in fields) {
				if (!firstInSequence) { Write(","); }
				WriteLine("");
				string prefix = (templateTypes.Contains(field.FieldType) || IsCollectionType(field.FieldType)) ? "" : "this."; #>
				ImmutableObjectGraph.Optional.For(<#= prefix + CamelCase(field.Name) #>)<#
				firstInSequence = false;
			} #>
);
		}
	}

	/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
	private struct Template {<#
	foreach(var field in fields) {
#>

		internal <#= GetTypeName(field.FieldType) #> <#= PascalCase(field.Name) #> { get; set; }
<#
	}
#>
	}
}
<# } // looping over all template types

	this.PopIndent();
#>
}
<#+
	public Type TemplateType { get; set; }

	public string Namespace { get; set; }

	protected static string PascalCase(string name) {
		return name.Substring(0,1).ToUpperInvariant() + name.Substring(1);
	}

	protected static string CamelCase(string name) {
		return name.Substring(0,1).ToLowerInvariant() + name.Substring(1);
	}

	protected static HashSet<Type> DiscoverTemplateTypes(Type rootType) {
		var types = new HashSet<Type>();
		var pendingTypes = new Queue<Type>();
		pendingTypes.Enqueue(rootType);
		while(pendingTypes.Count > 0)
		{
			var type = pendingTypes.Dequeue();
			if (types.Add(type)) {
				foreach(var field in type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic)) {
					var memberType = GetTypeOrCollectionMemberType(field.FieldType);

					if (memberType.DeclaringType == type.DeclaringType) {
						pendingTypes.Enqueue(memberType);
					}
				}
			}
		}

		return types;
	}
	
	protected string GetBuilderPropertyTypeName(Type type, HashSet<Type> templateTypes) {
		if (templateTypes.Contains(type) || IsCollectionType(type)) {
			return GetTypeName(type) + ".Builder";
		} else {
			return GetTypeName(type);
		}
	}

	protected string GetBuilderFieldTypeName(Type type, HashSet<Type> templateTypes) {
		if (templateTypes.Contains(type) || IsCollectionType(type)) {
			return "ImmutableObjectGraph.Optional<" + GetTypeName(type) + ".Builder>";
		} else {
			return GetTypeName(type);
		}
	}

	protected string GetTypeName(Type type) {
		var typeName = new StringBuilder();

		if (type.IsGenericType) {
			typeName.Append(type.FullName.Substring(0, type.FullName.IndexOf('`')));
			typeName.Append("<");
			foreach (Type typeArgument in type.GenericTypeArguments) {
				typeName.Append(GetTypeName(typeArgument));
				typeName.Append(", ");
			}

			typeName.Length -= 2;
			typeName.Append(">");
		} else {
			typeName.Append(type.DeclaringType == this.TemplateType.DeclaringType ? type.Name : type.FullName);
		}

		return typeName.ToString();
	}

	private static bool IsCollectionType(Type type) {
		if (type.IsArray) {
			return true;
		}

		if (type.IsGenericType && type.GenericTypeArguments.Length == 1) {
			Type readOnlyCollection = typeof(IReadOnlyCollection<>);
			var genericReadOnlyCollection = readOnlyCollection.MakeGenericType(type.GenericTypeArguments[0]);
			if (genericReadOnlyCollection.IsAssignableFrom(type)) {
				return true;
			}
		}

		return false;
	}

	private static bool TryGetCollectionElementType(Type collectionType, out Type elementType) {
		if (collectionType.IsArray) {
			elementType = collectionType.GetElementType();
			return true;
		}

		if (collectionType.IsGenericType && collectionType.GenericTypeArguments.Length == 1) {
			Type readOnlyCollection = typeof(IReadOnlyCollection<>);
			var genericReadOnlyCollection = readOnlyCollection.MakeGenericType(collectionType.GenericTypeArguments[0]);
			if (genericReadOnlyCollection.IsAssignableFrom(collectionType)) {
				elementType = collectionType.GenericTypeArguments[0];
				return true;
			}
		}

		elementType = null;
		return false;
	}

	private static Type GetTypeOrCollectionMemberType(Type collectionOrOtherType) {
		Type memberType;
		if (TryGetCollectionElementType(collectionOrOtherType, out memberType)) {
			return memberType;
		}

		return collectionOrOtherType;
	}

	protected string GetOptionalTypeName(Type type)
	{
		return "ImmutableObjectGraph.Optional<" + GetTypeName(type) + ">";
	}

#>
