<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="$(ProjectDir)..\packages\Microsoft.Bcl.Immutable.1.0.8-beta\lib\net45\System.Collections.Immutable.dll" #>
<#@ assembly name="$(ProjectDir)bin\debug\ImmutableObjectGraph.dll" #>
<#@ Import Namespace="ImmutableObjectGraph" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="System.Collections.Immutable" #>
<#@ import namespace="System.Linq" #>
<#@ Import Namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace <#= this.Namespace #> {
	using System.Diagnostics;
	using ImmutableObjectGraph;

<#
	this.PushIndent("\t");
	var templateTypes = DiscoverTemplateTypes();

	foreach(var templateType in templateTypes) {
#>

public interface I<#= templateType.Name #><#
	if (templateType.HasAncestor) {
		Write(" : I{0}", templateType.Ancestor.Name);
	}
#> {
<#
	foreach(var field in templateType.LocalFields) { #>
	<#= field.TypeName #> <#= field.NamePascalCase #> { get; }
<#	}
#>
}

public <#= templateType.IsAbstract ? "abstract " : "" #>partial class <#= templateType.Name #> : <#= templateType.HasAncestor ? (templateType.Ancestor.Name + ", ") : "" #>I<#= templateType.Name #><# if (templateType.IsRecursive) { #>, System.Collections.Generic.IEnumerable<<#=templateType.Name#>><# } #> {
<#	if (!templateType.IsAbstract) { #>
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static readonly <#= templateType.Name #> DefaultInstance = GetDefaultTemplate();
<#	}
	foreach(var field in templateType.LocalFields) {
#>

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly <#= GetTypeName(field.FieldType) #> <#= field.NameCamelCase #>;
<#
	}
#>

	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	protected <#= templateType.Name #>()
	{
	}

<#
	bool firstInSequence = true;
	if (templateType.LocalFields.Count > 0) { #>
	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	protected <#= templateType.Name #>(<# WriteParameters(templateType.AllFields, ParameterStyle.Required); #>)
		: base(<# WriteArguments(templateType.AllFields.Where(f => f.DeclaringType != templateType), ArgSource.Argument); #>)
	{
<#
	foreach(var field in templateType.LocalFields) {
#>
		this.<#= field.NameCamelCase #> = <#= field.NameCamelCase #>;
<#
	}

	if (!templateType.IsAbstract) {
#>
		this.Validate();
<#	} #>
	}
<# }

	if (!templateType.IsAbstract) { #>

	public static <#= templateType.Name #> Create(<# WriteParameters(templateType.AllFields, ParameterStyle.OptionalOrRequired); #>) {
		return DefaultInstance<# if (templateType.LocalFields.Count > 0) { #>.With(<#
		WriteArguments(templateType.AllFields, ArgSource.OptionalArgumentOrTemplate);
#>)<# } /* if (templateType.LocalFields.Count > 0) */ #>;
	}
<#
	} // !IsAbstract Create factory method

	foreach(var field in templateType.LocalFields) {
#>

	public <#= GetTypeName(field.FieldType) #> <#= field.NamePascalCase #> {
		get { return this.<#= field.NameCamelCase #>; }
	}
<#  } // foreach Fields

	foreach(var field in templateType.AllFields) {
		if (field.DeclaringType == templateType) { #>
	/// <summary>Returns a new instance with the <#= field.NamePascalCase #> property set to the specified value.</summary>
	public <#= templateType.Name #> With<#= field.NamePascalCase #>(<#= GetTypeName(field.FieldType) #> value) {
		if (value == this.<#= field.NamePascalCase #>) {
			return this;
		}

		return this.With(<#= field.NameCamelCase #>: value);
	}
<#
	Type elementType;
	if (TryGetCollectionElementType(field.FieldType, out elementType)) { #>

	/// <summary>Replaces the elements of the <#= field.NamePascalCase #> collection with the specified collection.</summary>
	public <#= templateType.Name #> With<#= field.NamePascalCase #>(params <#= GetTypeName(elementType) #>[] values) {
		return this.With(<#= field.NameCamelCase #>: this.<#=field.NamePascalCase#>.ResetContents(values));
	}

	/// <summary>Replaces the elements of the <#= field.NamePascalCase #> collection with the specified collection.</summary>
	public <#= templateType.Name #> With<#= field.NamePascalCase #>(System.Collections.Generic.IEnumerable<<#= GetTypeName(elementType) #>> values) {
		return this.With(<#= field.NameCamelCase #>: this.<#=field.NamePascalCase#>.ResetContents(values));
	}

	/// <summary>Adds the specified elements from the <#= field.NamePascalCase #> collection.</summary>
	public <#= templateType.Name #> Add<#= field.NamePascalCase #>(System.Collections.Generic.IEnumerable<<#= GetTypeName(elementType) #>> values) {
		return this.With(<#= field.NameCamelCase #>: this.<#=field.NamePascalCase#>.AddRange(values));
	}

	/// <summary>Adds the specified elements from the <#= field.NamePascalCase #> collection.</summary>
	public <#= templateType.Name #> Add<#= field.NamePascalCase #>(params <#= GetTypeName(elementType) #>[] values) {
		return this.With(<#= field.NameCamelCase #>: this.<#=field.NamePascalCase#>.AddRange(values));
	}

	/// <summary>Adds the specified element from the <#= field.NamePascalCase #> collection.</summary>
	public <#= templateType.Name #> Add<#= field.NamePascalCase #>(<#= GetTypeName(elementType) #> value) {
		return this.With(<#= field.NameCamelCase #>: this.<#=field.NamePascalCase#>.Add(value));
	}

	/// <summary>Removes the specified elements from the <#= field.NamePascalCase #> collection.</summary>
	public <#= templateType.Name #> Remove<#= field.NamePascalCase #>(System.Collections.Generic.IEnumerable<<#= GetTypeName(elementType) #>> values) {
		return this.With(<#= field.NameCamelCase #>: this.<#=field.NamePascalCase#>.RemoveRange(values));
	}

	/// <summary>Removes the specified elements from the <#= field.NamePascalCase #> collection.</summary>
	public <#= templateType.Name #> Remove<#= field.NamePascalCase #>(params <#= GetTypeName(elementType) #>[] values) {
		return this.With(<#= field.NameCamelCase #>: this.<#=field.NamePascalCase#>.RemoveRange(values));
	}

	/// <summary>Removes the specified element from the <#= field.NamePascalCase #> collection.</summary>
	public <#= templateType.Name #> Remove<#= field.NamePascalCase #>(<#= GetTypeName(elementType) #> value) {
		return this.With(<#= field.NameCamelCase #>: this.<#=field.NamePascalCase#>.Remove(value));
	}

	/// <summary>Clears all elements from the <#= field.NamePascalCase #> collection.</summary>
	public <#= templateType.Name #> Remove<#= field.NamePascalCase #>() {
		return this.With(<#= field.NameCamelCase #>: this.<#=field.NamePascalCase#>.Clear());
	}
<#		} // if field type is a collection
	} else { // else field appears on the base type
#>
	/// <summary>Returns a new instance with the <#= field.NamePascalCase #> property set to the specified value.</summary>
	public new <#= templateType.Name #> With<#= field.NamePascalCase #>(<#= GetTypeName(field.FieldType) #> value) {
		return (<#= templateType.Name #>)base.With<#= field.NamePascalCase #>(value);
	}
<#
	}
} // foreach field

	if (templateType.LocalFields.Count > 0) {
		if (templateType.HasAncestor) {
#>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public override <#= templateType.Ancestor.Name #> With(<# WriteParameters(templateType.Ancestor.AllFields, ParameterStyle.Optional); #>) {
		return this.With(<#
			WriteArguments(templateType.Ancestor.AllFields, ArgSource.Argument);
			Write(",");
			WriteArguments(templateType.LocalFields, ArgSource.Missing, namedArguments: true);
#>);
	}
	<# } /* templateType.HasAncestor */ #>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public <#= templateType.IsAbstract ? "abstract" : "virtual" #> <#= templateType.Name #> With(<#
		WriteParameters(templateType.AllFields, ParameterStyle.Optional);
#>)<# if (templateType.IsAbstract) { #>;<# } else { #> {
		if (<#
			firstInSequence = true;
			foreach(var field in templateType.AllFields) {
				if (!firstInSequence) { Write(" || "); }
				WriteLine("");
#>			(<#= field.NameCamelCase #>.IsDefined && <#= field.NameCamelCase #>.Value != this.<#= field.NamePascalCase #>)<#
				firstInSequence = false;
			}
	#>) {
			return new <#= templateType.Name #>(<# WriteArguments(templateType.AllFields, ArgSource.OptionalArgumentOrProperty, indent: 4); #>);
		} else {
			return this;
		}
	}
<#		} /* if isAbstract */ #>

<#	} /* templateType.LocalFields.Count > 0 */ #>

	public <#= templateType.HasAncestor ? "new ": "" #>Builder ToBuilder() {
		return new Builder(this);
	}

<#
	if (templateType.HasAncestor && !templateType.Ancestor.IsAbstract) {
#>
	public <#= templateType.Ancestor.Name#> To<#= templateType.Ancestor.Name#>() {
		return <#= templateType.Ancestor.Name #>.Create(<# WriteArguments(templateType.Ancestor.AllFields); #>);
	}
<#
	}

	if (!templateType.IsAbstract) {
		foreach (MetaType derivedType in templateType.Descendents.Where(d => !d.IsAbstract)) {
#>

	public virtual <#= derivedType.Name #> To<#= derivedType.Name #>(<# WriteParameters(derivedType.GetFieldsBeyond(templateType), ParameterStyle.Optional); #>) {
		<#= derivedType.Name #> that = this as <#= derivedType.Name #>;
		if (that != null && this.GetType().IsEquivalentTo(typeof(<#= derivedType.Name #>))) {
			if (<#
			firstInSequence = true;
			PushIndent("\t\t\t    ");
			foreach (var field in derivedType.GetFieldsBeyond(templateType)) {
				if (!firstInSequence) { WriteLine(" && "); }
				Write("(!{0}.IsDefined || {0}.Value == that.{1})", field.NameCamelCase, field.NamePascalCase);
				firstInSequence = false;
			}

			PopIndent();
			#>) {
				return that;
			}
		}

		return <#= derivedType.Name #>.Create(<#
WriteArguments(templateType.AllFields);
Write(",");
WriteArguments(derivedType.GetFieldsBeyond(templateType), ArgSource.Argument);
#>);
	}
<#
			foreach (var ancestor in templateType.GetNonAbstractAncestors()) { #>

	public override <#= derivedType.Name #> To<#= derivedType.Name #>(<# WriteParameters(derivedType.GetFieldsBeyond(ancestor), ParameterStyle.Optional); #>) {
		return base.To<#= derivedType.Name #>(<#
WriteArguments(templateType.GetFieldsBeyond(ancestor), ArgSource.OptionalArgumentOrProperty);
Write(",");
WriteArguments(derivedType.GetFieldsBeyond(templateType), ArgSource.Argument);
#>);
	}
<#			} // foreach ancestor type
		} // foreach derived type
	}
#>

 <# if (templateType.IsRecursive) { #>
	public System.Collections.Generic.IEnumerator<<#=templateType.Name#>> GetEnumerator() {
		return this.<#=templateType.RecursiveField.NameCamelCase#>.GetEnumerator();
	}

	System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
		return this.<#=templateType.RecursiveField.NameCamelCase#>.GetEnumerator();
	}

 <# }
	if (!templateType.IsAbstract) { #>

	/// <summary>Normalizes and/or validates all properties on this object.</summary>
	/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
	partial void Validate();

	/// <summary>Provides defaults for fields.</summary>
	/// <param name="template">The struct to set default values on.</param>
	static partial void CreateDefaultTemplate(ref Template template);

	/// <summary>Returns a newly instantiated <#= templateType.Name #> whose fields are initialized with default values.</summary>
	private static <#= templateType.Name #> GetDefaultTemplate() {
		var template = new Template();
		CreateDefaultTemplate(ref template);
		return new <#= templateType.Name #>(<#
		firstInSequence = true;
		this.PushIndent("\t\t\t");

		// Value parameters
		foreach(var field in templateType.AllFields) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write("template.");
			Write(field.NamePascalCase);
			firstInSequence = false;
		}

		this.PopIndent();
#>);
	}
<# } /* !IsAbstract */ #>

	public <#= templateType.HasAncestor ? "new ": "" #>partial class Builder<#
		if (templateType.HasAncestor) {
			Write(" : {0}.Builder", templateType.Ancestor.Name);
		}
#> {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private <#= templateType.Name #> immutable;
<#		foreach(var field in templateType.LocalFields) { #>

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		protected <#= field.TypeNameForBuilderField #> <#= field.NameCamelCase #>;
<#		} #>

		internal Builder(<#= templateType.Name #> immutable)<#
			if (templateType.HasAncestor) {
				Write(" : base(immutable)");
			} #> {
			this.immutable = immutable;

<#
			foreach(var field in templateType.LocalFields.Where(f => f.IsPrimitiveType)) {
#>
			this.<#= field.NameCamelCase #> = immutable.<#= field.NamePascalCase #>;
<#			} #>
		}
<#		foreach(var field in templateType.LocalFields) { #>

		public <#= field.TypeNameForBuilderProperty #> <#= field.NamePascalCase #> {
			get {
<# if (!field.IsPrimitiveType) { #>
				if (!this.<#= field.NameCamelCase #>.IsDefined) {
					this.<#= field.NameCamelCase #> = this.immutable.<#= field.NameCamelCase #> != null ? this.immutable.<#= field.NameCamelCase #>.ToBuilder() : null;
				}

				return this.<#= field.NameCamelCase #>.Value;
<# } else { #>
				return this.<#= field.NameCamelCase #>;
<# } #>
			}

			set {
				this.<#= field.NameCamelCase #> = value;
			}
		}
<#		} #>

		public <#= templateType.HasAncestor ? "new ": "" #><#= templateType.Name #> ToImmutable() {
<#			foreach(var templateField in templateType.AllFields.Where(f => !f.IsPrimitiveType)) { #>
			var <#= templateField.NameCamelCase #> = this.<#= templateField.NameCamelCase #>.IsDefined ? (this.<#= templateField.NameCamelCase #>.Value != null ? this.<#= templateField.NameCamelCase #>.Value.ToImmutable() : null) : this.immutable.<#= templateField.NamePascalCase #>;
<#			} #>
			return this.immutable = this.immutable<# if (templateType.LocalFields.Count > 0) { #>.With(<#
			firstInSequence = true;
			foreach(var field in templateType.AllFields) {
				if (!firstInSequence) { Write(","); }
				WriteLine("");
				if (!field.IsPrimitiveType) { #>
				ImmutableObjectGraph.Optional.For(<#= field.NameCamelCase #>)<#
				} else { #>
				ImmutableObjectGraph.Optional.For(this.<#= field.NamePascalCase #>)<#
				}
				firstInSequence = false;
			} #>
)<# } /* if (templateType.LocalFields.Count > 0) */ #>;
		}
	}
<# if (!templateType.IsAbstract) { #>

	/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
	private struct Template {<#
	foreach(var field in templateType.AllFields) {
#>

		internal <#= GetTypeName(field.FieldType) #> <#= field.NamePascalCase #> { get; set; }
<#
	}
#>
	}
<#	} /* !IsAbstract */ #>
}
<# } // looping over all template types

	this.PopIndent();
#>
}
<#+
	public string Namespace { get; set; }

	protected static string PascalCase(string name) {
		return name.Substring(0,1).ToUpperInvariant() + name.Substring(1);
	}

	protected static string CamelCase(string name) {
		return name.Substring(0,1).ToLowerInvariant() + name.Substring(1);
	}

	protected static HashSet<MetaType> DiscoverTemplateTypes() {
		var rootType = System.Reflection.MethodBase.GetCurrentMethod().DeclaringType;
		var types = new HashSet<MetaType>();
		var pendingTypes = new Queue<Type>();

		Func<Type, bool> includeTypeTest = t => t.GetCustomAttribute<System.Runtime.CompilerServices.CompilerGeneratedAttribute>() == null 
							&& !t.IsEquivalentTo(typeof(MetaType))
							&& !t.IsEquivalentTo(typeof(ArgSource))
							&& !t.IsEquivalentTo(typeof(ParameterStyle));

		foreach (var nestedType in rootType.GetNestedTypes(BindingFlags.NonPublic | BindingFlags.Public)) {
			if (includeTypeTest(nestedType)) {
				pendingTypes.Enqueue(nestedType);
			}
		}

		while (pendingTypes.Count > 0)
		{
			var type = pendingTypes.Dequeue();
			var metaType = new MetaType(type, types);
			if (types.Add(metaType)) {
				foreach(var field in metaType.LocalFields) {
					var memberType = field.ElementType;

					if (memberType.DeclaringType == type.DeclaringType) { // if this is a type that also appears in the T4 template
						pendingTypes.Enqueue(memberType);
					}
				}

				if (type.DeclaringType != null) {
					foreach (var siblingNestedType in type.DeclaringType.GetNestedTypes(BindingFlags.NonPublic | BindingFlags.Public)) {
						if (includeTypeTest(siblingNestedType)) {
							pendingTypes.Enqueue(siblingNestedType);
						}
					}
				}
			}
		}

		return types;
	}

	protected static string GetTypeName(Type type) {
		var typeName = new StringBuilder();

		if (type.IsGenericType) {
			typeName.Append(type.FullName.Substring(0, type.FullName.IndexOf('`')));
			typeName.Append("<");
			foreach (Type typeArgument in type.GenericTypeArguments) {
				typeName.Append(GetTypeName(typeArgument));
				typeName.Append(", ");
			}

			typeName.Length -= 2;
			typeName.Append(">");
		} else {
			var templateDeclaringType = System.Reflection.MethodBase.GetCurrentMethod().DeclaringType;
			typeName.Append(type.DeclaringType == templateDeclaringType ? type.Name : type.FullName);
		}

		return typeName.ToString();
	}

	private static bool IsCollectionType(Type type) {
		if (type.IsArray) {
			return true;
		}

		if (type.IsGenericType && type.GenericTypeArguments.Length == 1) {
			Type readOnlyCollection = typeof(IReadOnlyCollection<>);
			var genericReadOnlyCollection = readOnlyCollection.MakeGenericType(type.GenericTypeArguments[0]);
			if (genericReadOnlyCollection.IsAssignableFrom(type)) {
				return true;
			}
		}

		return false;
	}

	private static bool TryGetCollectionElementType(Type collectionType, out Type elementType) {
		if (collectionType.IsArray) {
			elementType = collectionType.GetElementType();
			return true;
		}

		if (collectionType.IsGenericType && collectionType.GenericTypeArguments.Length == 1) {
			Type readOnlyCollection = typeof(IReadOnlyCollection<>);
			var genericReadOnlyCollection = readOnlyCollection.MakeGenericType(collectionType.GenericTypeArguments[0]);
			if (genericReadOnlyCollection.IsAssignableFrom(collectionType)) {
				elementType = collectionType.GenericTypeArguments[0];
				return true;
			}
		}

		elementType = null;
		return false;
	}

	private static Type GetTypeOrCollectionMemberType(Type collectionOrOtherType) {
		Type memberType;
		if (TryGetCollectionElementType(collectionOrOtherType, out memberType)) {
			return memberType;
		}

		return collectionOrOtherType;
	}

	protected static string GetOptionalTypeName(Type type)
	{
		return "ImmutableObjectGraph.Optional<" + GetTypeName(type) + ">";
	}

	private enum ArgSource {
		Property,
		Argument,
		OptionalArgumentOrProperty,
		OptionalArgumentOrTemplate,
		Missing,
	}

	private void WriteArguments(IEnumerable<MetaType.MetaField> fields, ArgSource source = ArgSource.Property, bool namedArguments = false, int indent = 3) {
		PushIndent(new string('\t', indent));
		bool firstInSequence = true;
		foreach(var field in fields) {
			ArgSource fieldSource = (source == ArgSource.OptionalArgumentOrTemplate && field.IsRequired) ? ArgSource.Argument : source;
			if (!firstInSequence) { Write(","); }
			WriteLine("");
			if (namedArguments) {
				Write("{0}: ", field.NameCamelCase);
			}

			switch (fieldSource) {
				case ArgSource.Property:
					Write("this.{0}", field.NamePascalCase);
					break;
				case ArgSource.Argument:
					Write(field.NameCamelCase);
					break;
				case ArgSource.OptionalArgumentOrProperty:
					Write("{0}.GetValueOrDefault(this.{1})", field.NameCamelCase, field.NamePascalCase);
					break;
				case ArgSource.OptionalArgumentOrTemplate:
					Write("{0}.GetValueOrDefault(DefaultInstance.{1})", field.NameCamelCase, field.NamePascalCase);
					break;
				case ArgSource.Missing:
					Write("default({0})", field.OptionalTypeName);
					break;
			}

			firstInSequence = false;
		}

		PopIndent();
	}

	private enum ParameterStyle {
		Required,
		Optional,
		OptionalOrRequired,
	}

	private void WriteParameters(IEnumerable<MetaType.MetaField> fields, ParameterStyle style) {
		PushIndent("\t\t");
		bool firstInSequence = true;
		foreach(var field in fields) {
			bool fieldOptional = style == ParameterStyle.Optional || (style == ParameterStyle.OptionalOrRequired && !field.IsRequired);
			if (!firstInSequence) { Write(","); }
			WriteLine("");
			Write(fieldOptional ? field.OptionalTypeName : field.TypeName);
			Write(" ");
			Write(field.NameCamelCase);
			if (fieldOptional) {
				Write(" = default(" + field.OptionalTypeName + ")");
			}

			firstInSequence = false;
		}
		PopIndent();
	}

	protected class MetaType {
		private readonly ISet<MetaType> knownTypes;

		public MetaType(Type type, ISet<MetaType> knownTypes) {
			this.Type = type;
			this.knownTypes = knownTypes;
		}

		public Type Type { get; private set; }

		public string Name {
			get { return this.Type.Name; }
		}

		public ImmutableList<MetaField> LocalFields {
			get { return this.Type.GetFields(BindingFlags.NonPublic | BindingFlags.Instance).Select(f => new MetaField(f, this)).ToImmutableList(); }
		}

		public ImmutableList<MetaField> AllFields {
			get {
				var fieldsWithBase = this.LocalFields;
				if (this.HasAncestor) {
					fieldsWithBase = fieldsWithBase.InsertRange(0, this.Ancestor.AllFields);
				}

				return fieldsWithBase;
			}
		}

		public MetaField RecursiveField {
			get { return this.LocalFields.SingleOrDefault(f => f.IsCollection && f.ElementType == this.Type); }
		}

		public bool IsRecursive {
			get { return this.LocalFields.Count(f => f.IsCollection && f.ElementType == this.Type) == 1; }
		}

		public MetaType Ancestor {
			get { return this.knownTypes.FirstOrDefault(mt => mt.Type.IsEquivalentTo(this.Type.BaseType)); }
		}

		public bool HasAncestor {
			get { return this.Ancestor != null; }
		}

		public IEnumerable<MetaType> Descendents {
			get { return this.knownTypes.Where(t => this.Type.IsAssignableFrom(t.Type) && !this.Type.IsEquivalentTo(t.Type)); }
		}

		public bool HasDescendent {
			get { return this.Descendents.Any(); }
		}

		public bool IsAbstract { 
			get { return this.Type.IsAbstract; }
		}

		public string TypeName {
			get { return this.Type.Name; }
		}

		public string OptionalTypeName {
			get { return GetOptionalTypeName(this.Type); }
		}

		public IEnumerable<MetaField> GetFieldsBeyond(MetaType ancestor) {
			var fields = ImmutableList.Create<MetaField>();
			if (ancestor != this) {
				fields = fields.AddRange(this.LocalFields)
				               .InsertRange(0, this.Ancestor.GetFieldsBeyond(ancestor));
			}

			return fields;
		}

		public IEnumerable<MetaType> GetNonAbstractAncestors() {
			for (var ancestor = this.Ancestor; ancestor != null; ancestor = ancestor.Ancestor) {
				if (!ancestor.IsAbstract) {
					yield return ancestor;
				}
			}
		}

		public override int GetHashCode() {
			return this.Type.GetHashCode();
		}

		public override bool Equals(object value) {
			var other = value as MetaType;
			return other != null && this.Type.IsEquivalentTo(other.Type);
		}

		public class MetaField {
			public MetaField(FieldInfo field, MetaType declaringType) {
				this.Field = field;
				this.DeclaringType = declaringType;
			}

			public FieldInfo Field { get; private set; }

			public Type FieldType {
				get { return this.Field.FieldType; }
			}

			public MetaType DeclaringType { get; private set; }

			public string NamePascalCase {
				get { return PascalCase(this.Field.Name); }
			}

			public string NameCamelCase {
				get { return CamelCase(this.Field.Name); }
			}

			public bool IsRequired {
				get { return this.Field.GetCustomAttribute<RequiredAttribute>() != null; }
			}

			public bool IsCollection {
				get { return IsCollectionType(this.Field.FieldType); }
			}

			public bool IsPrimitiveType {
				get { return !this.DeclaringType.knownTypes.Any(mt => mt.Type.IsEquivalentTo(this.FieldType)) && !this.IsCollection; }
			}
			
			public Type ElementType {
				get { return GetTypeOrCollectionMemberType(this.Field.FieldType); }
			}

			public string ElementTypeName {
				get { return GetTypeName(GetTypeOrCollectionMemberType(this.Field.FieldType)); }
			}

			public string TypeName {
				get { return GetTypeName(this.Field.FieldType); }
			}

			public string OptionalTypeName {
				get { return GetOptionalTypeName(this.Field.FieldType); }
			}

			public string TypeNameForBuilderField {
				get {
					return this.DeclaringType.knownTypes.Any(mt => mt.Type.IsEquivalentTo(this.FieldType)) || IsCollectionType(this.FieldType)
						? "ImmutableObjectGraph.Optional<" + this.TypeName + ".Builder>"
						: this.TypeName;
				}
			}

			public string TypeNameForBuilderProperty {
				get {
					return this.DeclaringType.knownTypes.Any(mt => mt.Type.IsEquivalentTo(this.FieldType)) || IsCollectionType(this.FieldType)
						? this.TypeName + ".Builder"
						: this.TypeName;
				}
			}
		}
	}

#>
