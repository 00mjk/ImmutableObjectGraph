<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="C:\Users\Andrew\git\ImmutableObjectGraph\packages\Microsoft.Bcl.Immutable.1.0.8-beta\lib\net45\System.Collections.Immutable.dll" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="System.Collections.Immutable" #>
<#@ import namespace="System.Linq" #>
<#@ Import Namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace <#= this.Namespace #> {
	using System.Diagnostics;
	using ImmutableObjectGraph;

<#
	this.PushIndent("\t");
	var templateTypes = DiscoverTemplateTypes();

	foreach(var templateType in templateTypes) {
		// We use the recursive strategy when the templateType has exactly one collection of its own type.
		var recursiveFields = templateType.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Where(f => IsCollectionType(f.FieldType) && f.FieldType.GenericTypeArguments[0] == templateType);
		bool recursive = recursiveFields.Count() == 1;
		var fields = templateType.GetFields(BindingFlags.NonPublic | BindingFlags.Instance).ToImmutableList();
		var fieldsWithBase = fields;
		var recursiveBaseType = templateType;
		while ((recursiveBaseType = recursiveBaseType.BaseType) != null) {
			fieldsWithBase = fieldsWithBase.InsertRange(0, recursiveBaseType.GetFields(BindingFlags.NonPublic | BindingFlags.Instance));
		}
#>

public interface I<#= templateType.Name #> {
<#
	foreach(var field in fields) { #>
	<#= GetTypeName(field.FieldType) #> <#= PascalCase(field.Name) #> { get; }
<#	}
#>
}

public <#= templateType.IsAbstract ? "abstract " : "" #>partial class <#= templateType.Name #> : <#= GetTypeName(templateType.BaseType) #>, I<#= templateType.Name #><# if (recursive) { #>, System.Collections.Generic.IEnumerable<<#=templateType.Name#>><# } #> {
<#	if (!templateType.IsAbstract) { #>
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static readonly <#= templateType.Name #> DefaultInstance = GetDefaultTemplate();
<#	}
	foreach(var field in fields) {
#>

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly <#= GetTypeName(field.FieldType) #> <#= CamelCase(field.Name) #>;
<#
	}
#>

	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	protected <#= templateType.Name #>()
	{
	}

<#
	bool firstInSequence = true;
	if (fields.Count > 0) { #>
	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	protected <#= templateType.Name #>(<#
	foreach(var field in fieldsWithBase) {
		if (!firstInSequence) { Write(", "); }
		Write(GetTypeName(field.FieldType));
		Write(" ");
		Write(CamelCase(field.Name));
		firstInSequence = false;
	}
#>)
		: base(<#
	firstInSequence = true;
	foreach(var field in fieldsWithBase.Where(f => f.DeclaringType != templateType)) {
		if (!firstInSequence) Write(",");
		Write(CamelCase(field.Name));
		firstInSequence = false;
	}
#>)
	{
<#
	foreach(var field in fields) {
#>
		this.<#= CamelCase(field.Name) #> = <#= CamelCase(field.Name) #>;
<#
	}

	if (!templateType.IsAbstract) {
#>
		this.Validate();
<#	} #>
	}
<# }

	if (!templateType.IsAbstract) { #>

	public static <#= templateType.Name #> Create(<#
		firstInSequence = true;
		this.PushIndent("\t\t");

		// Value parameters
		foreach(var field in fieldsWithBase) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write(GetOptionalTypeName(field.FieldType));
			Write(" ");
			Write(CamelCase(field.Name));
			Write(" = default(" + GetOptionalTypeName(field.FieldType) + ")");
			firstInSequence = false;
		}

		this.PopIndent();
#>) {
		return DefaultInstance<# if (fields.Count > 0) { #>.With(<#
		firstInSequence = true;
		this.PushIndent("\t\t\t");

		// Value parameters
		foreach(var field in fieldsWithBase) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			#><#=CamelCase(field.Name)#>.IsDefined ? <#=CamelCase(field.Name)#> : ImmutableObjectGraph.Optional.For(DefaultInstance.<#=PascalCase(field.Name)#>)<#
			firstInSequence = false;
		}

		this.PopIndent();
#>)<# } /* if (fields.Count > 0) */ #>;
	}
<#
	} // !IsAbstract Create factory method

	foreach(var field in fields) {
#>

	public <#= GetTypeName(field.FieldType) #> <#= PascalCase(field.Name) #> {
		get { return this.<#= CamelCase(field.Name) #>; }
	}
<#  } // foreach Fields

	foreach(var field in fieldsWithBase) {
		if (field.DeclaringType == templateType) { #>
	/// <summary>Returns a new instance with the <#= PascalCase(field.Name) #> property set to the specified value.</summary>
	public <#= templateType.Name #> With<#= PascalCase(field.Name) #>(<#= GetTypeName(field.FieldType) #> value) {
		if (value == this.<#= PascalCase(field.Name) #>) {
			return this;
		}

		return this.With(<#= CamelCase(field.Name) #>: value);
	}
<#
	Type elementType;
	if (TryGetCollectionElementType(field.FieldType, out elementType)) { #>

	/// <summary>Replaces the elements of the <#= PascalCase(field.Name) #> collection with the specified collection.</summary>
	public <#= templateType.Name #> With<#= PascalCase(field.Name) #>(params <#= GetTypeName(elementType) #>[] values) {
		return this.With(<#= CamelCase(field.Name) #>: this.<#=PascalCase(field.Name)#>.ResetContents(values));
	}

	/// <summary>Replaces the elements of the <#= PascalCase(field.Name) #> collection with the specified collection.</summary>
	public <#= templateType.Name #> With<#= PascalCase(field.Name) #>(System.Collections.Generic.IEnumerable<<#= GetTypeName(elementType) #>> values) {
		return this.With(<#= CamelCase(field.Name) #>: this.<#=PascalCase(field.Name)#>.ResetContents(values));
	}

	/// <summary>Adds the specified elements from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Add<#= PascalCase(field.Name) #>(System.Collections.Generic.IEnumerable<<#= GetTypeName(elementType) #>> values) {
		return this.With(<#= CamelCase(field.Name) #>: this.<#=PascalCase(field.Name)#>.AddRange(values));
	}

	/// <summary>Adds the specified elements from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Add<#= PascalCase(field.Name) #>(params <#= GetTypeName(elementType) #>[] values) {
		return this.With(<#= CamelCase(field.Name) #>: this.<#=PascalCase(field.Name)#>.AddRange(values));
	}

	/// <summary>Adds the specified element from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Add<#= PascalCase(field.Name) #>(<#= GetTypeName(elementType) #> value) {
		return this.With(<#= CamelCase(field.Name) #>: this.<#=PascalCase(field.Name)#>.Add(value));
	}

	/// <summary>Removes the specified elements from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Remove<#= PascalCase(field.Name) #>(System.Collections.Generic.IEnumerable<<#= GetTypeName(elementType) #>> values) {
		return this.With(<#= CamelCase(field.Name) #>: this.<#=PascalCase(field.Name)#>.RemoveRange(values));
	}

	/// <summary>Removes the specified elements from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Remove<#= PascalCase(field.Name) #>(params <#= GetTypeName(elementType) #>[] values) {
		return this.With(<#= CamelCase(field.Name) #>: this.<#=PascalCase(field.Name)#>.RemoveRange(values));
	}

	/// <summary>Removes the specified element from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Remove<#= PascalCase(field.Name) #>(<#= GetTypeName(elementType) #> value) {
		return this.With(<#= CamelCase(field.Name) #>: this.<#=PascalCase(field.Name)#>.Remove(value));
	}

	/// <summary>Clears all elements from the <#= PascalCase(field.Name) #> collection.</summary>
	public <#= templateType.Name #> Remove<#= PascalCase(field.Name) #>() {
		return this.With(<#= CamelCase(field.Name) #>: this.<#=PascalCase(field.Name)#>.Clear());
	}
<#		} // if field type is a collection
	} else { // else field appears on the base type
#>
	/// <summary>Returns a new instance with the <#= PascalCase(field.Name) #> property set to the specified value.</summary>
	public new <#= templateType.Name #> With<#= PascalCase(field.Name) #>(<#= GetTypeName(field.FieldType) #> value) {
		return (<#= templateType.Name #>)base.With<#= PascalCase(field.Name) #>(value);
	}
<#
	}
} // foreach field

	if (fields.Count > 0) {
		if (templateTypes.Contains(templateType.BaseType)) {
#>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public override <#= templateType.BaseType.Name #> With(<#
		firstInSequence = true;
		this.PushIndent("\t\t");

		// Value parameters
		foreach(var field in fieldsWithBase.Where(f => f.DeclaringType != templateType)) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write(GetOptionalTypeName(field.FieldType));
			Write(" ");
			Write(CamelCase(field.Name));
			Write(" = default(" + GetOptionalTypeName(field.FieldType) + ")");
			firstInSequence = false;
		}

		this.PopIndent();
		#>) {
		return this.With(
<#
		firstInSequence = true;
		this.PushIndent("\t\t\t");
		foreach (var field in fieldsWithBase) {
			if (!firstInSequence) { WriteLine(", "); }
			Write(CamelCase(field.Name));
			Write(": ");
			if (field.DeclaringType == templateType) {
				Write("default(" + GetOptionalTypeName(field.FieldType) + ")");
			} else {
				Write(CamelCase(field.Name));
			}

			firstInSequence = false;
		}

		this.PopIndent();
#>);
	}
	<# } /* templateTypes.Contains(templateType.BaseType) */ #>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public <#= templateType.IsAbstract ? "abstract" : "virtual" #> <#= templateType.Name #> With(<#
		firstInSequence = true;
		this.PushIndent("\t\t");

		// Value parameters
		foreach(var field in fieldsWithBase) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write(GetOptionalTypeName(field.FieldType));
			Write(" ");
			Write(CamelCase(field.Name));
			Write(" = default(" + GetOptionalTypeName(field.FieldType) + ")");
			firstInSequence = false;
		}

		this.PopIndent();
#>)<# if (templateType.IsAbstract) { #>;<# } else { #> {
		if (<#
			firstInSequence = true;
			foreach(var field in fieldsWithBase) {
				if (!firstInSequence) { Write(" || "); }
				WriteLine("");
#>			(<#= CamelCase(field.Name) #>.IsDefined && <#= CamelCase(field.Name) #>.Value != this.<#= PascalCase(field.Name) #>)<#
				firstInSequence = false;
			}
	#>) {
			return new <#= templateType.Name #>(<#
				firstInSequence = true;
				foreach(var field in fieldsWithBase) {
					if (!firstInSequence) { Write(","); }
					WriteLine("");
	#>				<#= CamelCase(field.Name) #>.IsDefined ? <#= CamelCase(field.Name) #>.Value : this.<#= PascalCase(field.Name) #><#
					firstInSequence = false;
				}
		#>);
		} else {
			return this;
		}
	}
<#		} /* if isAbstract */ #>

<#	} /* fields.Count > 0 */ #>

	public Builder ToBuilder() {
		return new Builder(this);
	}

 <# if (recursive) { #>
	public System.Collections.Generic.IEnumerator<<#=templateType.Name#>> GetEnumerator() {
		return this.<#=CamelCase(recursiveFields.Single().Name)#>.GetEnumerator();
	}

	System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
		return this.<#=CamelCase(recursiveFields.Single().Name)#>.GetEnumerator();
	}

 <# }
	if (!templateType.IsAbstract) { #>

	/// <summary>Normalizes and/or validates all properties on this object.</summary>
	/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
	partial void Validate();

	/// <summary>Provides defaults for fields.</summary>
	/// <param name="template">The struct to set default values on.</param>
	static partial void CreateDefaultTemplate(ref Template template);

	/// <summary>Returns a newly instantiated <#= templateType.Name #> whose fields are initialized with default values.</summary>
	private static <#= templateType.Name #> GetDefaultTemplate() {
		var template = new Template();
		CreateDefaultTemplate(ref template);
		return new <#= templateType.Name #>(<#
		firstInSequence = true;
		this.PushIndent("\t\t\t");

		// Value parameters
		foreach(var field in fieldsWithBase) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write("template.");
			Write(PascalCase(field.Name));
			firstInSequence = false;
		}

		this.PopIndent();
#>);
	}
<# } /* !IsAbstract */ #>

	public partial class Builder<#
		if (templateTypes.Contains(templateType.BaseType)) {
			Write(" : {0}.Builder", templateType.BaseType.Name);
		}
#> {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private <#= templateType.Name #> immutable;
<#		foreach(var field in fields) { #>

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private <#= GetBuilderFieldTypeName(field.FieldType, templateTypes) #> <#= CamelCase(field.Name) #>;
<#		} #>

		internal Builder(<#= templateType.Name #> immutable)<#
			if (templateTypes.Contains(templateType.BaseType)) {
				Write(" : base(immutable)");
			} #> {
			this.immutable = immutable;

<#
			foreach(var field in fields.Where(f => !templateTypes.Contains(f.FieldType) && !IsCollectionType(f.FieldType))) {
#>
			this.<#= CamelCase(field.Name) #> = immutable.<#= PascalCase(field.Name) #>;
<#			} #>
		}
<#		foreach(var field in fields) { #>

		public <#= GetBuilderPropertyTypeName(field.FieldType, templateTypes) #> <#= PascalCase(field.Name) #> {
			get {
<# if (templateTypes.Contains(field.FieldType) || IsCollectionType(field.FieldType)) { #>
				if (!this.<#= CamelCase(field.Name) #>.IsDefined) {
					this.<#= CamelCase(field.Name) #> = this.immutable.<#= CamelCase(field.Name) #> != null ? this.immutable.<#= CamelCase(field.Name) #>.ToBuilder() : null;
				}

				return this.<#= CamelCase(field.Name) #>.Value;
<# } else { #>
				return this.<#= CamelCase(field.Name) #>;
<# } #>
			}

			set {
				this.<#= CamelCase(field.Name) #> = value;
			}
		}
<#		} #>

		public <#= templateType.Name #> ToImmutable() {
<#			foreach(var templateField in fields.Where(f => templateTypes.Contains(f.FieldType) || IsCollectionType(f.FieldType))) { #>
			var <#= CamelCase(templateField.Name) #> = this.<#= CamelCase(templateField.Name) #>.IsDefined ? (this.<#= CamelCase(templateField.Name) #>.Value != null ? this.<#= CamelCase(templateField.Name) #>.Value.ToImmutable() : null) : this.immutable.<#= CamelCase(templateField.Name) #>;
<#			} #>
			return this.immutable = this.immutable<# if (fields.Count > 0) { #>.With(<#
			firstInSequence = true;
			foreach(var field in fieldsWithBase) {
				if (!firstInSequence) { Write(","); }
				WriteLine("");
				if (templateTypes.Contains(field.FieldType) || IsCollectionType(field.FieldType)) { #>
				ImmutableObjectGraph.Optional.For(<#= CamelCase(field.Name) #>)<#
				} else { #>
				ImmutableObjectGraph.Optional.For(this.<#= PascalCase(field.Name) #>)<#
				}
				firstInSequence = false;
			} #>
)<# } /* if (fields.Count > 0) */ #>;
		}
	}
<# if (!templateType.IsAbstract) { #>

	/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
	private struct Template {<#
	foreach(var field in fieldsWithBase) {
#>

		internal <#= GetTypeName(field.FieldType) #> <#= PascalCase(field.Name) #> { get; set; }
<#
	}
#>
	}
<#	} /* !IsAbstract */ #>
}
<# } // looping over all template types

	this.PopIndent();
#>
}
<#+
	public string Namespace { get; set; }

	protected static string PascalCase(string name) {
		return name.Substring(0,1).ToUpperInvariant() + name.Substring(1);
	}

	protected static string CamelCase(string name) {
		return name.Substring(0,1).ToLowerInvariant() + name.Substring(1);
	}

	protected static HashSet<Type> DiscoverTemplateTypes() {
		var rootType = System.Reflection.MethodBase.GetCurrentMethod().DeclaringType;
		var types = new HashSet<Type>();
		var pendingTypes = new Queue<Type>();

		foreach (var nestedType in rootType.GetNestedTypes(BindingFlags.NonPublic | BindingFlags.Public)) {
			if (nestedType.GetCustomAttribute<System.Runtime.CompilerServices.CompilerGeneratedAttribute>() == null) {
				pendingTypes.Enqueue(nestedType);
			}
		}

		while (pendingTypes.Count > 0)
		{
			var type = pendingTypes.Dequeue();
			if (types.Add(type)) {
				foreach(var field in type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic)) {
					var memberType = GetTypeOrCollectionMemberType(field.FieldType);

					if (memberType.DeclaringType == type.DeclaringType) {
						pendingTypes.Enqueue(memberType);
					}
				}

				if (type.DeclaringType != null) {
					foreach (var siblingNestedType in type.DeclaringType.GetNestedTypes(BindingFlags.NonPublic | BindingFlags.Public)) {
						if (siblingNestedType.GetCustomAttribute<System.Runtime.CompilerServices.CompilerGeneratedAttribute>() == null) {
							pendingTypes.Enqueue(siblingNestedType);
						}
					}
				}
			}
		}

		return types;
	}
	
	protected string GetBuilderPropertyTypeName(Type type, HashSet<Type> templateTypes) {
		if (templateTypes.Contains(type) || IsCollectionType(type)) {
			return GetTypeName(type) + ".Builder";
		} else {
			return GetTypeName(type);
		}
	}

	protected string GetBuilderFieldTypeName(Type type, HashSet<Type> templateTypes) {
		if (templateTypes.Contains(type) || IsCollectionType(type)) {
			return "ImmutableObjectGraph.Optional<" + GetTypeName(type) + ".Builder>";
		} else {
			return GetTypeName(type);
		}
	}

	protected string GetTypeName(Type type) {
		var typeName = new StringBuilder();

		if (type.IsGenericType) {
			typeName.Append(type.FullName.Substring(0, type.FullName.IndexOf('`')));
			typeName.Append("<");
			foreach (Type typeArgument in type.GenericTypeArguments) {
				typeName.Append(GetTypeName(typeArgument));
				typeName.Append(", ");
			}

			typeName.Length -= 2;
			typeName.Append(">");
		} else {
			var templateDeclaringType = System.Reflection.MethodBase.GetCurrentMethod().DeclaringType;
			typeName.Append(type.DeclaringType == templateDeclaringType ? type.Name : type.FullName);
		}

		return typeName.ToString();
	}

	private static bool IsCollectionType(Type type) {
		if (type.IsArray) {
			return true;
		}

		if (type.IsGenericType && type.GenericTypeArguments.Length == 1) {
			Type readOnlyCollection = typeof(IReadOnlyCollection<>);
			var genericReadOnlyCollection = readOnlyCollection.MakeGenericType(type.GenericTypeArguments[0]);
			if (genericReadOnlyCollection.IsAssignableFrom(type)) {
				return true;
			}
		}

		return false;
	}

	private static bool TryGetCollectionElementType(Type collectionType, out Type elementType) {
		if (collectionType.IsArray) {
			elementType = collectionType.GetElementType();
			return true;
		}

		if (collectionType.IsGenericType && collectionType.GenericTypeArguments.Length == 1) {
			Type readOnlyCollection = typeof(IReadOnlyCollection<>);
			var genericReadOnlyCollection = readOnlyCollection.MakeGenericType(collectionType.GenericTypeArguments[0]);
			if (genericReadOnlyCollection.IsAssignableFrom(collectionType)) {
				elementType = collectionType.GenericTypeArguments[0];
				return true;
			}
		}

		elementType = null;
		return false;
	}

	private static Type GetTypeOrCollectionMemberType(Type collectionOrOtherType) {
		Type memberType;
		if (TryGetCollectionElementType(collectionOrOtherType, out memberType)) {
			return memberType;
		}

		return collectionOrOtherType;
	}

	protected string GetOptionalTypeName(Type type)
	{
		return "ImmutableObjectGraph.Optional<" + GetTypeName(type) + ">";
	}

#>
