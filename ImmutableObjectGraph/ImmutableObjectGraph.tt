<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Data.Entity.Design" #>
<#@ assembly name="$(ProjectDir)..\packages\Microsoft.Bcl.Immutable.1.0.8-beta\lib\net45\System.Collections.Immutable.dll" #>
<#@ assembly name="$(ProjectDir)bin\debug\ImmutableObjectGraph.dll" #>
<#@ Import Namespace="ImmutableObjectGraph" #>
<#@ Import namespace="System.Globalization" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="System.Collections.Immutable" #>
<#@ Import Namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ Import Namespace="System.Reflection" #>
<#@ Import namespace="System.Text" #>
<#@ Import namespace="System.Data.Entity.Design.PluralizationServices" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.Discovery.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.Interface.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.WithProperty.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.CollectionHelpers.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.DeepMutation.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.FastSpine.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.TypeConversion.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.Builders.tt" #>
<#
	this.PluralService = PluralizationService.CreateService(CultureInfo.CurrentCulture);
#>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace <#= this.Namespace #> {
	using System.Diagnostics;
	using System.Linq;
	using ImmutableObjectGraph;
<#
	this.PushIndent("\t");
	foreach(var templateType in TemplateTypes) {
		this.OnHandleType(templateType, HandleTypePosition.BeforeTypeDeclaration);
#>

public <#= templateType.IsAbstract ? "abstract " : "" #>partial class <#= templateType.TypeName #> : <#= templateType.HasAncestor ? (templateType.Ancestor.TypeName + ", ") : "" #>I<#= templateType.TypeName #><# if (templateType.IsRecursive) { #>, System.Collections.Generic.IEnumerable<<#=templateType.RecursiveType.TypeName#>><# } #> {
<#	if (!templateType.IsAbstract) { #>
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static readonly <#= templateType.TypeName #> DefaultInstance = GetDefaultTemplate();
<#	}

	if (!templateType.HasAncestor) {
#>
	
	/// <summary>The last identity assigned to a created instance.</summary>
	private static int lastIdentityProduced;
<#
	}

	foreach(var field in templateType.LocalFields) {
#>

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly <#= field.TypeName #> <#= field.NameCamelCase #>;
<#
	}

	if (!templateType.HasAncestor) {
#>

	private readonly <#= templateType.RequiredIdentityField.TypeName #> <#= templateType.RequiredIdentityField.NameCamelCase #>;
<#
	}
#>

<#
	bool firstInSequence = true;
#>
	/// <summary>Initializes a new instance of the <#= templateType.TypeName #> class.</summary>
	protected <#= templateType.TypeName #>(<#
		WriteParameters(templateType.RequiredIdentityField.Concat(templateType.AllFields), ParameterStyle.Required);
		if (templateType.Equals(templateType.RecursiveParent)) {
			WriteParameters(new [] { templateType.LookupTableField }, ParameterStyle.Optional, concatenated: true);
		}
#>)
<# if (templateType.HasAncestor) { #>
		: base(<# WriteArguments(templateType.RequiredIdentityField.Concat(templateType.AllFields.Where(f => f.DeclaringType != templateType)), ArgSource.Argument); #>)
<# } #>
	{
<#
	if (!templateType.HasAncestor) {
#>
		this.<#= templateType.RequiredIdentityField.NameCamelCase #> = <#= templateType.RequiredIdentityField.NameCamelCase #>;
<#
	}

	foreach(var field in templateType.LocalFields) {
#>
		this.<#= field.NameCamelCase #> = <#= field.NameCamelCase #>;
<#
	}

	if (!templateType.IsAbstract) {
#>
		this.Validate();
<#	} #>
<#	OnHandleType(templateType, HandleTypePosition.InsideConstructor); #>
	}
<#
	if (!templateType.IsAbstract) { #>

	public static <#= templateType.TypeName #> Create(<# WriteParameters(templateType.AllFields, ParameterStyle.OptionalOrRequired); #>) {
		var <#= templateType.RequiredIdentityField.NameCamelCase #> = Optional.For(NewIdentity());
		return DefaultInstance<# if (templateType.LocalFields.Count > 0) { #>.WithFactory(<#
		WriteArguments(templateType.AllFields.Concat(templateType.OptionalIdentityField), ArgSource.OptionalArgumentOrTemplate, asOptional: OptionalStyle.Always);
#>)<# } /* if (templateType.LocalFields.Count > 0) */ #>;
	}
<#
		if (templateType.LocalFields.Count > 0) {
#>

	internal static <#= templateType.TypeName #> CreateWithIdentity(<# WriteParameters(templateType.AllFields.Concat(templateType.OptionalIdentityField), ParameterStyle.OptionalOrRequired); #>) {
		if (!<#= templateType.OptionalIdentityField.NameCamelCase #>.IsDefined) {
			<#= templateType.OptionalIdentityField.NameCamelCase #> = NewIdentity();
		}

		return DefaultInstance.WithFactory(<#
		WriteArguments(templateType.AllFields.Concat(templateType.OptionalIdentityField), ArgSource.OptionalArgumentOrTemplate, asOptional: OptionalStyle.Always); 
#>);
	}
<#
		} // templateType.LocalFields.Count > 0
	} // !IsAbstract Create factory method

	foreach(var field in templateType.LocalFields) {
#>

	public <#= field.TypeName #> <#= field.NamePascalCase #> {
		get { return this.<#= field.NameCamelCase #>; }
	}
<#  } // foreach Fields

	foreach(var field in templateType.AllFields) {
		this.OnHandleField(templateType, field);
	}

	if (templateType.LocalFields.Count > 0) {
		if (templateType.HasAncestor) {
#>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public override <#= templateType.Ancestor.TypeName #> With(<# WriteParameters(templateType.Ancestor.AllFields, ParameterStyle.Optional); #>) {
		return this.With(<#
			WriteArguments(templateType.Ancestor.AllFields, ArgSource.Argument);
			Write(",");
			WriteArguments(templateType.LocalFields, ArgSource.Missing);
#>);
	}
	<# } /* templateType.HasAncestor */ #>
	
	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public <#= templateType.IsAbstract ? "abstract" : "virtual" #> <#= templateType.TypeName #> With(<#
		WriteParameters(templateType.AllFields, ParameterStyle.Optional);
#>)<# if (templateType.IsAbstract) { #>;
<# } else { #> {
		var <#= templateType.RequiredIdentityField.NameCamelCase #> = default(<#= templateType.RequiredIdentityField.OptionalTypeName#>);
		return this.WithFactory(<# WriteArguments(templateType.AllFields.Concat(templateType.OptionalIdentityField), ArgSource.OptionalArgumentOrProperty, asOptional: OptionalStyle.Always); #>);
	}
<#		} /* if isAbstract */

		if (!templateType.IsAbstract) {
 #>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	private <#= templateType.TypeName #> WithFactory(<# WriteParameters(templateType.AllFields.Concat(templateType.OptionalIdentityField), ParameterStyle.Optional); #>) {
		if (<#
			firstInSequence = true;
			foreach(var field in templateType.RequiredIdentityField.Concat(templateType.AllFields)) {
				if (!firstInSequence) { Write(" || "); }
				WriteLine("");
#>			(<#= field.NameCamelCase #>.IsDefined && <#= field.NameCamelCase #>.Value != this.<#= field.NamePascalCase #>)<#
				firstInSequence = false;
			}
	#>) {
<#
			if (templateType.Equals(templateType.RecursiveParent)) {
#>
			var <#= templateType.LookupTableField.NameCamelCase #> = <#= templateType.RecursiveField.NameCamelCase #>.IsDefined && <#= templateType.RecursiveField.NameCamelCase #>.Value != this.<#= templateType.RecursiveField.NamePascalCase #> ? default(Optional<<#= templateType.NodeLookupTableTypeName #>>) : Optional.For(this.lookupTable);
<#
			}
#>
			return new <#= templateType.TypeName #>(<#
				WriteArguments(templateType.RequiredIdentityField.Concat(templateType.AllFields), ArgSource.OptionalArgumentOrProperty, indent: 4);
				if (templateType.Equals(templateType.RecursiveParent)) {
					WriteArguments(new [] { templateType.LookupTableField }, ArgSource.Argument, indent: 4, concatenated: true);
				}
#>);
		} else {
			return this;
		}
	}
<#
		}
	} /* templateType.LocalFields.Count > 0 */
	
	if (!templateType.HasAncestor) {
#>

	protected internal <#= templateType.RequiredIdentityField.TypeName #> <#= templateType.RequiredIdentityField.NamePascalCase #> {
		get { return this.<#= templateType.RequiredIdentityField.NameCamelCase #>; }
	}

	/// <summary>Returns a unique identity that may be assigned to a newly created instance.</summary>
	protected static <#= templateType.RequiredIdentityField.TypeName #> NewIdentity() {
		return System.Threading.Interlocked.Increment(ref lastIdentityProduced);
	}
<#	} // !templateType.HasAncestor

	if (templateType.IsRecursive) { #>

	public System.Collections.Generic.IEnumerator<<#=templateType.RecursiveType.TypeName#>> GetEnumerator() {
		return this.<#=templateType.RecursiveField.NameCamelCase#>.GetEnumerator();
	}

	System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
		return this.<#=templateType.RecursiveField.NameCamelCase#>.GetEnumerator();
	}
<# }
	if (!templateType.IsAbstract) { #>

	/// <summary>Normalizes and/or validates all properties on this object.</summary>
	/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
	partial void Validate();

	/// <summary>Provides defaults for fields.</summary>
	/// <param name="template">The struct to set default values on.</param>
	static partial void CreateDefaultTemplate(ref Template template);

	/// <summary>Returns a newly instantiated <#= templateType.TypeName #> whose fields are initialized with default values.</summary>
	private static <#= templateType.TypeName #> GetDefaultTemplate() {
		var template = new Template();
		CreateDefaultTemplate(ref template);
		return new <#= templateType.TypeName #>(<#
		this.PushIndent("\t\t\t");

		// Value parameters
		WriteLine("");
		Write("default({0})", templateType.RequiredIdentityField.TypeName);
		foreach(var field in templateType.AllFields) {
			Write(", ");
			WriteLine("");
			Write("template.");
			Write(field.NamePascalCase);
		}

		this.PopIndent();
#>);
	}
<# } /* !IsAbstract */
if (!templateType.IsAbstract) { #>

	/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
	private struct Template {<#
	foreach(var field in templateType.AllFields) {
#>

		internal <#= field.TypeName #> <#= field.NamePascalCase #> { get; set; }
<#
	}
#>
	}
<#	} /* !IsAbstract */

	this.OnHandleType(templateType, HandleTypePosition.WithinTypeDeclaration, indent: 1);
#>
}
<#
		this.OnHandleType(templateType, HandleTypePosition.AfterTypeDeclaration);
	} // looping over all template types

	this.PopIndent();
#>
}

<#+
	public PluralizationService PluralService { get; set; }

	public string Namespace { get; set; }

	protected enum HandleTypePosition {
		BeforeTypeDeclaration,

		InsideConstructor,

		WithinTypeDeclaration,

		AfterTypeDeclaration,
	}

	protected event Action<MetaType, HandleTypePosition> HandleType;

	protected event Action<MetaType, HandleTypePosition> HandleRedType;

	protected event Action<MetaType, MetaType.MetaField> HandleField;

	protected event Action<MetaType, MetaType.MetaField> HandleRedField;

	protected void OnHandleType(MetaType type, HandleTypePosition position, int indent = 0) {
		var handleType = this.HandleType;
		if (handleType != null) {
			this.PushIndent(new string('\t', indent));
			handleType(type, position);
			this.PopIndent();
		}
	}

	protected void OnHandleRedType(MetaType type, HandleTypePosition position, int indent = 0) {
		var handleRedType = this.HandleRedType;
		if (handleRedType != null) {
			this.PushIndent(new string('\t', indent));
			handleRedType(type, position);
			this.PopIndent();
		}
	}

	protected void OnHandleField(MetaType type, MetaType.MetaField field) {
		var handleField = this.HandleField;
		if (handleField != null) {
			this.PushIndent("\t");
			handleField(type, field);
			this.PopIndent();
		}
	}

	protected void OnHandleRedField(MetaType type, MetaType.MetaField field) {
		var handleRedField = this.HandleRedField;
		if (handleRedField != null) {
			this.PushIndent("\t");
			handleRedField(type, field);
			this.PopIndent();
		}
	}

	protected void WriteBaseTypes(params string[] typeNames) {
		var elements = typeNames.Where(t => t != null);
		if (elements.Any()) {
			Write(" : ");
			bool firstElement = true;
			foreach (var element in elements) {
				if (!firstElement) {
					Write(", ");
				}

				Write(element);
				firstElement = false;
			}
		}
	}
#>
