<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="$(ProjectDir)..\packages\Microsoft.Bcl.Immutable.1.0.8-beta\lib\net45\System.Collections.Immutable.dll" #>
<#@ assembly name="$(ProjectDir)bin\debug\ImmutableObjectGraph.dll" #>
<#@ Import Namespace="ImmutableObjectGraph" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="System.Collections.Immutable" #>
<#@ import namespace="System.Linq" #>
<#@ Import Namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.Discovery.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.WithProperty.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.CollectionHelpers.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.Builders.tt" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace <#= this.Namespace #> {
	using System.Diagnostics;
	using ImmutableObjectGraph;

<#
	this.PushIndent("\t");
	var templateTypes = DiscoverTemplateTypes();

	foreach(var templateType in templateTypes) {
#>

public interface I<#= templateType.Name #><#
	if (templateType.HasAncestor) {
		Write(" : I{0}", templateType.Ancestor.Name);
	}
#> {
<#
	foreach(var field in templateType.LocalFields) { #>
	<#= field.TypeName #> <#= field.NamePascalCase #> { get; }
<#	}
#>
}

public <#= templateType.IsAbstract ? "abstract " : "" #>partial class <#= templateType.Name #> : <#= templateType.HasAncestor ? (templateType.Ancestor.Name + ", ") : "" #>I<#= templateType.Name #><# if (templateType.IsRecursive) { #>, System.Collections.Generic.IEnumerable<<#=templateType.Name#>><# } #> {
<#	if (!templateType.IsAbstract) { #>
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static readonly <#= templateType.Name #> DefaultInstance = GetDefaultTemplate();
<#	}
	foreach(var field in templateType.LocalFields) {
#>

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly <#= GetTypeName(field.FieldType) #> <#= field.NameCamelCase #>;
<#
	}
#>

	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	protected <#= templateType.Name #>()
	{
	}

<#
	bool firstInSequence = true;
	if (templateType.LocalFields.Count > 0) { #>
	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	protected <#= templateType.Name #>(<# WriteParameters(templateType.AllFields, ParameterStyle.Required); #>)
		: base(<# WriteArguments(templateType.AllFields.Where(f => f.DeclaringType != templateType), ArgSource.Argument); #>)
	{
<#
	foreach(var field in templateType.LocalFields) {
#>
		this.<#= field.NameCamelCase #> = <#= field.NameCamelCase #>;
<#
	}

	if (!templateType.IsAbstract) {
#>
		this.Validate();
<#	} #>
	}
<# }

	if (!templateType.IsAbstract) { #>

	public static <#= templateType.Name #> Create(<# WriteParameters(templateType.AllFields, ParameterStyle.OptionalOrRequired); #>) {
		return DefaultInstance<# if (templateType.LocalFields.Count > 0) { #>.With(<#
		WriteArguments(templateType.AllFields, ArgSource.OptionalArgumentOrTemplate);
#>)<# } /* if (templateType.LocalFields.Count > 0) */ #>;
	}
<#
	} // !IsAbstract Create factory method

	foreach(var field in templateType.LocalFields) {
#>

	public <#= GetTypeName(field.FieldType) #> <#= field.NamePascalCase #> {
		get { return this.<#= field.NameCamelCase #>; }
	}
<#  } // foreach Fields

	foreach(var field in templateType.AllFields) {
		this.OnHandleField(templateType, field);
	}

	if (templateType.LocalFields.Count > 0) {
		if (templateType.HasAncestor) {
#>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public override <#= templateType.Ancestor.Name #> With(<# WriteParameters(templateType.Ancestor.AllFields, ParameterStyle.Optional); #>) {
		return this.With(<#
			WriteArguments(templateType.Ancestor.AllFields, ArgSource.Argument);
			Write(",");
			WriteArguments(templateType.LocalFields, ArgSource.Missing);
#>);
	}
	<# } /* templateType.HasAncestor */ #>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public <#= templateType.IsAbstract ? "abstract" : "virtual" #> <#= templateType.Name #> With(<#
		WriteParameters(templateType.AllFields, ParameterStyle.Optional);
#>)<# if (templateType.IsAbstract) { #>;<# } else { #> {
		if (<#
			firstInSequence = true;
			foreach(var field in templateType.AllFields) {
				if (!firstInSequence) { Write(" || "); }
				WriteLine("");
#>			(<#= field.NameCamelCase #>.IsDefined && <#= field.NameCamelCase #>.Value != this.<#= field.NamePascalCase #>)<#
				firstInSequence = false;
			}
	#>) {
			return new <#= templateType.Name #>(<# WriteArguments(templateType.AllFields, ArgSource.OptionalArgumentOrProperty, indent: 4); #>);
		} else {
			return this;
		}
	}
<#		} /* if isAbstract */ #>

<#	} /* templateType.LocalFields.Count > 0 */ #>

<#
	if (templateType.HasAncestor && !templateType.Ancestor.IsAbstract) {
#>
	public <#= templateType.Ancestor.Name#> To<#= templateType.Ancestor.Name#>() {
		return <#= templateType.Ancestor.Name #>.Create(<# WriteArguments(templateType.Ancestor.AllFields); #>);
	}
<#
	}

	if (!templateType.IsAbstract) {
		foreach (MetaType derivedType in templateType.Descendents.Where(d => !d.IsAbstract)) {
#>

	public virtual <#= derivedType.Name #> To<#= derivedType.Name #>(<# WriteParameters(derivedType.GetFieldsBeyond(templateType), ParameterStyle.OptionalOrRequired); #>) {
		<#= derivedType.Name #> that = this as <#= derivedType.Name #>;
		if (that != null && this.GetType().IsEquivalentTo(typeof(<#= derivedType.Name #>))) {
			if (<#
			firstInSequence = true;
			PushIndent("\t\t\t    ");
			foreach (var field in derivedType.GetFieldsBeyond(templateType)) {
				if (!firstInSequence) { WriteLine(" && "); }
				if (field.IsRequired) {
					Write("({0} == that.{1})", field.NameCamelCase, field.NamePascalCase);
				} else {
					Write("(!{0}.IsDefined || {0}.Value == that.{1})", field.NameCamelCase, field.NamePascalCase);
				}

				firstInSequence = false;
			}

			PopIndent();
			#>) {
				return that;
			}
		}

		return <#= derivedType.Name #>.Create(<#
WriteArguments(templateType.AllFields);
Write(",");
WriteArguments(derivedType.GetFieldsBeyond(templateType), ArgSource.Argument);
#>);
	}
<#
			foreach (var ancestor in templateType.GetNonAbstractAncestors()) { #>

	public override <#= derivedType.Name #> To<#= derivedType.Name #>(<# WriteParameters(derivedType.GetFieldsBeyond(ancestor), ParameterStyle.OptionalOrRequired); #>) {
		return base.To<#= derivedType.Name #>(<#
WriteArguments(templateType.GetFieldsBeyond(ancestor), ArgSource.OptionalArgumentOrProperty);
Write(",");
WriteArguments(derivedType.GetFieldsBeyond(templateType), ArgSource.Argument);
#>);
	}
<#			} // foreach ancestor type
		} // foreach derived type
	}
#>

 <# if (templateType.IsRecursive) { #>
	public System.Collections.Generic.IEnumerator<<#=templateType.Name#>> GetEnumerator() {
		return this.<#=templateType.RecursiveField.NameCamelCase#>.GetEnumerator();
	}

	System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
		return this.<#=templateType.RecursiveField.NameCamelCase#>.GetEnumerator();
	}

 <# }
	if (!templateType.IsAbstract) { #>

	/// <summary>Normalizes and/or validates all properties on this object.</summary>
	/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
	partial void Validate();

	/// <summary>Provides defaults for fields.</summary>
	/// <param name="template">The struct to set default values on.</param>
	static partial void CreateDefaultTemplate(ref Template template);

	/// <summary>Returns a newly instantiated <#= templateType.Name #> whose fields are initialized with default values.</summary>
	private static <#= templateType.Name #> GetDefaultTemplate() {
		var template = new Template();
		CreateDefaultTemplate(ref template);
		return new <#= templateType.Name #>(<#
		firstInSequence = true;
		this.PushIndent("\t\t\t");

		// Value parameters
		foreach(var field in templateType.AllFields) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write("template.");
			Write(field.NamePascalCase);
			firstInSequence = false;
		}

		this.PopIndent();
#>);
	}
<# } /* !IsAbstract */ #>

<# if (!templateType.IsAbstract) { #>

	/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
	private struct Template {<#
	foreach(var field in templateType.AllFields) {
#>

		internal <#= GetTypeName(field.FieldType) #> <#= field.NamePascalCase #> { get; set; }
<#
	}
#>
	}
<#	} /* !IsAbstract */

	this.OnHandleType(templateType);
#>

}

<#
	} // looping over all template types

	this.PopIndent();
#>
}

<#+
	public string Namespace { get; set; }

	protected event Action<MetaType> HandleType;

	protected event Action<MetaType, MetaType.MetaField> HandleField;

	protected void OnHandleType(MetaType type) {
		var handleType = this.HandleType;
		if (handleType != null) {
			this.PushIndent("\t");
			handleType(type);
			this.PopIndent();
		}
	}

	protected void OnHandleField(MetaType type, MetaType.MetaField field) {
		var handleField = this.HandleField;
		if (handleField != null) {
			this.PushIndent("\t");
			handleField(type, field);
			this.PopIndent();
		}
	}
#>
