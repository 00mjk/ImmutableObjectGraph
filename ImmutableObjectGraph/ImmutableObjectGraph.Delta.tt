<#
this.HandleType += (templateType, position) => {
	if (templateType.IsRecursiveType) {
		string enumTypeName = GetPropertiesEnumTypeName(templateType);
		string diffTypeName = GetDiffGramTypeName(templateType);
		switch (position) {
			case HandleTypePosition.WithinTypeDeclaration:
#>

/// <summary>
/// A description of a change made to an instance of an immutable object.
/// </summary>
[DebuggerDisplay("{Kind} {(Before ?? After).Caption} ({<#= templateType.RequiredIdentityField.NamePascalCase #>}) {Changes}")]
public struct DiffGram {
	private DiffGram(<#= templateType.TypeName #> before, <#= templateType.TypeName #> after, ChangeKind kind, <#= enumTypeName #> changes)
		: this() {
		this.Before = before;
		this.After = after;
		this.Kind = kind;
		this.Changes = changes;
	}

	public static DiffGram Change(<#= templateType.TypeName #> before, <#= templateType.TypeName #> after, <#= enumTypeName #> changes) {
		return new DiffGram(before, after, ChangeKind.Replaced, changes);
	}

	public static DiffGram Add(<#= templateType.TypeName #> value) {
		return new DiffGram(null, value, ChangeKind.Added, default(<#= enumTypeName #>));
	}

	public static DiffGram Remove(<#= templateType.TypeName #> value) {
		return new DiffGram(value, null, ChangeKind.Removed, default(<#= enumTypeName #>));
	}

	/// <summary>
	/// Gets the leaf node before the change.
	/// </summary>
	public <#= templateType.TypeName #> Before { get; private set; }

	/// <summary>
	/// Gets the leaf node after the change.
	/// </summary>
	public <#= templateType.TypeName #> After { get; private set; }

	/// <summary>
	/// Gets the kind of change made to the alterered node.
	/// </summary>
	public ChangeKind Kind { get; private set; }

	/// <summary>
	/// Gets the kinds of changes made to node if <see cref="Kind"/> is <see cref="ChangeKind.Replaced"/>.
	/// </summary>
	public <#= enumTypeName #> Changes { get; private set; }

	/// <summary>
	/// Gets the identity of the affected object.
	/// </summary>
	public <#= templateType.RequiredIdentityField.TypeName #> <#= templateType.RequiredIdentityField.NamePascalCase #> {
		get { return (this.Before ?? this.After).<#= templateType.RequiredIdentityField.NamePascalCase #>; }
	}
}

public static class Comparers {
	/// <summary>Gets an equatable comparer that considers only the persistent identity of a pair of values.</summary>
	public static System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> <#= templateType.RequiredIdentityField.NamePascalCase #> {
		get { return IdentityEqualityComparer.Default; }
	}

	/// <summary>Gets an equatable comparer that compares all properties between two instances.</summary>
	public static System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> ByValue {
		get { return ValueEqualityComparer.Shallow; }
	}

	/// <summary>Gets an equatable comparer that considers all properties between two instances and their children.</summary>
	public static System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> ByValueWithDescendents {
		get { return ValueEqualityComparer.Deep; }
	}

	internal static System.Collections.Generic.IEqualityComparer<Parented<#= templateType.TypeName #>> Parented<#= templateType.TypeName #><#= templateType.RequiredIdentityField.NamePascalCase #> {
		get { return Parented<#= templateType.TypeName #>EqualityComparer.Default; }
	}

	/// <summary>An equatable and sorting comparer that considers only the persistent identity of a pair of values.</summary>
	private class IdentityEqualityComparer : System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> {
		internal static readonly System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> Default = new IdentityEqualityComparer();

		private IdentityEqualityComparer() {
		}

		public bool Equals(<#= templateType.TypeName #> x, <#= templateType.TypeName #> y) {
			return x.<#= templateType.RequiredIdentityField.NamePascalCase #> == y.<#= templateType.RequiredIdentityField.NamePascalCase #>;
		}

		public int GetHashCode(<#= templateType.TypeName #> obj) {
			return obj.<#= templateType.RequiredIdentityField.NamePascalCase #>.GetHashCode();
		}
	}

	private class ValueEqualityComparer : System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> {
		internal static readonly System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> Shallow = new ValueEqualityComparer(false);

		internal static readonly System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> Deep = new ValueEqualityComparer(true);

		private bool includeRecursiveChildren;

		private ValueEqualityComparer(bool includeRecursiveChildren) {
			this.includeRecursiveChildren = includeRecursiveChildren;
		}

		public bool Equals(<#= templateType.TypeName #> x, <#= templateType.TypeName #> y) {
			if (x == null && y == null) {
				return true;
			}

			if (x == null ^ y == null) {
				return false;
			}

			if (this.includeRecursiveChildren) {
				throw new System.NotImplementedException();
			}

			return x.DiffProperties(y) == <#= enumTypeName #>.None;
		}

		public int GetHashCode(<#= templateType.TypeName #> obj) {
			return obj.<#= templateType.RequiredIdentityField.NamePascalCase #>.GetHashCode();
		}
	}

	private class Parented<#= templateType.TypeName #>EqualityComparer : System.Collections.Generic.IEqualityComparer<Parented<#= templateType.TypeName #>> {
		internal static readonly System.Collections.Generic.IEqualityComparer<Parented<#= templateType.TypeName #>> Default = new Parented<#= templateType.TypeName #>EqualityComparer();

		private Parented<#= templateType.TypeName #>EqualityComparer() {
		}
		
		public bool Equals(Parented<#= templateType.TypeName #> x, Parented<#= templateType.TypeName #> y) {
			return x.Value.<#= templateType.RequiredIdentityField.NamePascalCase #> == y.Value.<#= templateType.RequiredIdentityField.NamePascalCase #>;
		}

		public int GetHashCode(Parented<#= templateType.TypeName #> obj) {
			return obj.Value.<#= templateType.RequiredIdentityField.NamePascalCase #>;
		}
	}
}
<# if (!templateType.IsRecursiveParent) { #>

public virtual System.Collections.Generic.IReadOnlyList<<#= diffTypeName #>> ChangesSince(<#= templateType.TypeName #> priorVersion) {
	if (priorVersion == null) {
		throw new System.ArgumentNullException("priorVersion");
	}

	if (priorVersion.<#= templateType.RequiredIdentityField.NamePascalCase #> != this.<#= templateType.RequiredIdentityField.NamePascalCase #>) {
		throw new System.ArgumentException("Not another version of the same node.", "priorVersion");
	}

	var history = new System.Collections.Generic.List<<#= diffTypeName #>>();
	var changes = this.DiffProperties(priorVersion);
	if (changes != <#= enumTypeName #>.None) {
		history.Add(<#= diffTypeName #>.Change(priorVersion, this, changes));
	}

	return history;
}
<# } #>

protected virtual <#= enumTypeName #> DiffProperties(<#= templateType.TypeName #> other) {
	if (other == null) {
		throw new System.ArgumentNullException("other");
	}

	var propertiesChanged = <#= enumTypeName #>.None;

	if (this != other) {
		if (!this.GetType().IsEquivalentTo(other.GetType())) {
			propertiesChanged |= <#= enumTypeName #>.Type;
		}
<#
	var additionalFields = templateType.LocalFields.Where(f => !f.IsRecursiveCollection);
	foreach (var field in additionalFields) {
#>

		if (this.<#= field.NamePascalCase #> != other.<#= field.NamePascalCase #>) {
			propertiesChanged |= <#= enumTypeName #>.<#= field.NamePascalCase #>;
		}
<#
	}
#>
	}

	return propertiesChanged;
}

partial struct Parented<#= templateType.TypeName #> {
	public <#= enumTypeName #> DiffProperties(Parented<#= templateType.TypeName #> other) {
		<#= enumTypeName #> changes = this.Value.DiffProperties(other.Value);
		if ((this.Parent == null ^ other.Parent == null) || (this.Parent != null && other.Parent != null && this.Parent.<#= templateType.RequiredIdentityField.NamePascalCase #> != other.Parent.<#= templateType.RequiredIdentityField.NamePascalCase #>)) {
			changes |= <#= enumTypeName #>.Parent;
		} else if (this.Value != other.Value && this.Parent != null && other.Parent != null) {
			if (this.Parent.<#= templateType.RecursiveParent.RecursiveField.NamePascalCase #>.KeyComparer.Compare(this.Value, other.Value) != 0) {
				// Calculate where the node was, and where it would go in the old tree.
				int beforeIndex = other.Parent.<#= templateType.RecursiveParent.RecursiveField.NamePascalCase #>.IndexOf(other.Value);
				int afterIndex = ~other.Parent.<#= templateType.RecursiveParent.RecursiveField.NamePascalCase #>.IndexOf(this.Value);

				// If the indices are the same, the new one would come "just before" the old one.
				// If the new index is just 1 greater than the old index, the new one would come "just after" the old one.
				// In either of these cases, since the old one will be gone in the new tree, the position hasn't changed.
				if (afterIndex != beforeIndex && afterIndex != beforeIndex + 1) {
					changes |= <#= enumTypeName #>.PositionUnderParent;
				}
			}
		}

		return changes;
	}
}
<#
				break;
			case HandleTypePosition.AfterTypeDeclaration:
#>

[System.Flags]
public enum <#= enumTypeName #> {
	/// <summary>
	/// No change was made to the node.  It was either entirely added or removed. 
	/// </summary>
	None = 0x0,

	/// <summary>
	/// The type of the node was changed.
	/// </summary>
	Type = 0x1,

	/// <summary>
	/// The node's position within its parent's list of children changed.
	/// </summary>
	PositionUnderParent = 0x2,
	
	/// <summary>
	/// The node was removed and reappeared in a new position in the tree (with a different parent).
	/// </summary>
	Parent = 0x4,
<#
				int counter = 3;
				// We're interested in enumerating the union of all fields on this and derived types,
				// excluding the recursive collection itself.
				var fields = templateType.Concat(templateType.Descendents)
					.SelectMany(t => t.LocalFields)
					.Where(f => !f.IsRecursiveCollection);
				foreach (var field in fields) {
#>

	/// <summary>
	/// The <see cref="<#= field.DeclaringType.TypeName #>.<#= field.NamePascalCase #>" /> property was changed.
	/// </summary>
	<#= field.NamePascalCase #> = <#= string.Format("0x{0:x}", (int)Math.Pow(2, counter)) #>,
<#
					counter++;
				}
#>

	/// <summary>
	/// All flags in this enum.
	/// </summary>
	All = Type | PositionUnderParent | Parent<#
	foreach (var field in fields) {
		Write(" | ");
		Write(field.NamePascalCase);
	}
#>,
}
<#
				break;
			default:
				break;
		}
	} else if (templateType.IsDerivedFromRecursiveType) {
		MetaType recursiveType = templateType.RecursiveTypeFromFamily;
		string enumTypeName = GetPropertiesEnumTypeName(recursiveType);
		string diffTypeName = GetDiffGramTypeName(recursiveType);
		switch (position) {
			case HandleTypePosition.WithinTypeDeclaration:
				var additionalFields = templateType.LocalFields.Where(f => !f.IsRecursiveCollection);
				if (additionalFields.Any()) {
#>

protected override <#= enumTypeName #> DiffProperties(<#= recursiveType.TypeName #> other) {
	var propertiesChanged = base.DiffProperties(other);

	var other<#= templateType.TypeName #> = other as <#= templateType.TypeName #>;
	if (other<#= templateType.TypeName #> != null) {<#
	foreach (var field in additionalFields) {
#>

		if (this.<#= field.NamePascalCase #> != other<#= templateType.TypeName #>.<#= field.NamePascalCase #>) {
			propertiesChanged |= <#= enumTypeName #>.<#= field.NamePascalCase #>;
		}
<#
	}
#>
	}

	return propertiesChanged;
}
<#
				}

				break;
			default:
				break;
		} // switch
	} // if derived from recursive type

	if (templateType.IsRecursiveParent) {
		MetaType recursiveType = templateType.RecursiveTypeFromFamily;
		string enumTypeName = GetPropertiesEnumTypeName(recursiveType);
		string diffTypeName = GetDiffGramTypeName(recursiveType);
		string parentedTemplateType = "Parented" + templateType.RecursiveType.TypeName;
		switch (position) {
			case HandleTypePosition.WithinTypeDeclaration:
				string changesSinceKeyword = templateType.HasAncestor ? "override " : "virtual ";
#>

public <#= changesSinceKeyword #>System.Collections.Generic.IReadOnlyList<<#= diffTypeName #>> ChangesSince(<#= recursiveType.TypeName #> priorVersion) {
	if (priorVersion == null) {
		throw new System.ArgumentNullException("priorVersion");
	}

	if (this == priorVersion) {
		return System.Collections.Immutable.ImmutableList.Create<<#= diffTypeName #>>();
	}

	if (priorVersion.<#= templateType.RequiredIdentityField.NamePascalCase #> != this.<#= templateType.RequiredIdentityField.NamePascalCase #>) {
		throw new System.ArgumentException("Not another version of the same node.", "priorVersion");
	}

	var before = new System.Collections.Generic.HashSet<<#= parentedTemplateType #>>(priorVersion.GetSelfAndDescendentsWithParents(null), Comparers.<#= parentedTemplateType #><#= templateType.RequiredIdentityField.NamePascalCase #>);
	var after = new System.Collections.Generic.HashSet<<#= parentedTemplateType #>>(this.GetSelfAndDescendentsWithParents(null), Comparers.<#= parentedTemplateType #><#= templateType.RequiredIdentityField.NamePascalCase #>);

	var added = new System.Collections.Generic.HashSet<<#= parentedTemplateType #>>(Comparers.<#= parentedTemplateType #><#= templateType.RequiredIdentityField.NamePascalCase #>);
	var removed = new System.Collections.Generic.HashSet<<#= parentedTemplateType #>>(Comparers.<#= parentedTemplateType #><#= templateType.RequiredIdentityField.NamePascalCase #>);
	var changed = new System.Collections.Generic.Dictionary<<#= parentedTemplateType #>, <#= parentedTemplateType #>>(Comparers.<#= parentedTemplateType #><#= templateType.RequiredIdentityField.NamePascalCase #>);

	var descendentsOfAddOrRemove = new System.Collections.Generic.HashSet<<#= templateType.RecursiveType.TypeName #>>(Comparers.<#= templateType.RequiredIdentityField.NamePascalCase #>);
	
	foreach (var fromBefore in before) {
		if (after.Contains(fromBefore)) {
			var fromAfter = this.GetParentedNode(fromBefore.Value.<#= templateType.RequiredIdentityField.NamePascalCase #>);
			if (!object.ReferenceEquals(fromBefore.Value, fromAfter.Value) || fromBefore.Parent.<#= templateType.RequiredIdentityField.NamePascalCase #> != fromAfter.Parent.<#= templateType.RequiredIdentityField.NamePascalCase #>) {
				changed.Add(fromBefore, fromAfter);
			}
		} else {
			removed.Add(fromBefore);
		}
	}

	foreach (var fromAfter in after) {
		if (!before.Contains(fromAfter)) {
			added.Add(fromAfter);
		}
	}

	foreach (var topLevelOperation in added.Concat(removed)) {
		descendentsOfAddOrRemove.UnionWith(topLevelOperation.Value.GetSelfAndDescendents().Skip(1));
	}
		
	var history = new System.Collections.Generic.List<<#= diffTypeName #>>();
	history.AddRange(removed.Where(r => !descendentsOfAddOrRemove.Contains(r.Value)).Select(r => <#= diffTypeName #>.Remove(r.Value)));

	foreach (var changedNode in changed) {
		var oldNode = changedNode.Key;
		var newNode = changedNode.Value;
		
		<#= enumTypeName #> diff = newNode.DiffProperties(oldNode);
		if (diff != <#= enumTypeName #>.None) {
			history.Add(<#= diffTypeName #>.Change(oldNode.Value, newNode.Value, diff));
		}
	}

	history.AddRange(added.Where(a => !descendentsOfAddOrRemove.Contains(a.Value)).Select(a => <#= diffTypeName #>.Add(a.Value)));

	return history;
}
<#
				break;
			default:
				break;
		} // switch
	} // if IsRecursiveParent
}; // green type event handler

this.HandleRedType += (templateType, position) => {
	MetaType recursiveType = templateType.RecursiveTypeFromFamily;
	string enumTypeName = GetPropertiesEnumTypeName(recursiveType.GreenType);
	string diffTypeName = GetDiffGramTypeName(recursiveType.GreenType);
	switch (position) {
		case HandleTypePosition.WithinTypeDeclaration:
#>

	public System.Collections.Generic.IReadOnlyList<<#= diffTypeName #>> ChangesSince(<#= templateType.TypeName #> priorVersion) {
		this.ThrowIfDefault();
		return this.greenNode.ChangesSince(priorVersion.<#= templateType.GreenType.TypeName #>);
	}
<#
			break;
		default:
			break;
	}
}; // red type event handler
#><#+
	private string GetPropertiesEnumTypeName(MetaType templateType) {
		return templateType.TypeName + "ChangedProperties";
	}

	private string GetDiffGramTypeName(MetaType templateType) {
		return templateType.TypeName + ".DiffGram";
	}
#>
