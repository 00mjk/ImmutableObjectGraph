<#
this.HandleType += (templateType, position) => {
	if (templateType.IsRecursiveType) {
		string enumTypeName = GetPropertiesEnumTypeName(templateType);
		string diffTypeName = GetDiffGramTypeName(templateType);
		switch (position) {
			case HandleTypePosition.WithinTypeDeclaration:
#>

/// <summary>
/// A description of a change made to an instance of an immutable object.
/// </summary>
public struct DiffGram {
	private DiffGram(<#= templateType.TypeName #> before, <#= templateType.TypeName #> after, ChangeKind kind, <#= enumTypeName #> changes)
		: this() {
		this.Before = before;
		this.After = after;
		this.Kind = kind;
		this.Changes = changes;
	}

	public static DiffGram Change(<#= templateType.TypeName #> before, <#= templateType.TypeName #> after, <#= enumTypeName #> changes) {
		return new DiffGram(before, after, ChangeKind.Replaced, changes);
	}

	public static DiffGram Add(<#= templateType.TypeName #> value) {
		return new DiffGram(null, value, ChangeKind.Added, default(<#= enumTypeName #>));
	}

	public static DiffGram Remove(<#= templateType.TypeName #> value) {
		return new DiffGram(value, null, ChangeKind.Removed, default(<#= enumTypeName #>));
	}

	/// <summary>
	/// Gets the leaf node before the change.
	/// </summary>
	public <#= templateType.TypeName #> Before { get; private set; }

	/// <summary>
	/// Gets the leaf node after the change.
	/// </summary>
	public <#= templateType.TypeName #> After { get; private set; }

	/// <summary>
	/// Gets the kind of change made to the alterered node.
	/// </summary>
	public ChangeKind Kind { get; private set; }

	/// <summary>
	/// Gets the kinds of changes made to node if <see cref="Kind"/> is <see cref="ChangeKind.Replaced"/>.
	/// </summary>
	public <#= enumTypeName #> Changes { get; private set; }

	/// <summary>
	/// Gets the identity of the affected object.
	/// </summary>
	public <#= templateType.RequiredIdentityField.TypeName #> Identity {
		get { return (this.Before ?? this.After).Identity; }
	}
}

public static class Comparers {
	/// <summary>Gets an equatable comparer that considers only the persistent identity of a pair of values.</summary>
	public static System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> Identity {
		get { return IdentityEqualityComparer.Default; }
	}

	/// <summary>Gets an equatable comparer that compares all properties between two instances.</summary>
	public static System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> ByValue {
		get { return ValueEqualityComparer.Shallow; }
	}

	/// <summary>Gets an equatable comparer that considers all properties between two instances and their children.</summary>
	public static System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> ByValueWithDescendents {
		get { return ValueEqualityComparer.Deep; }
	}

	/// <summary>An equatable and sorting comparer that considers only the persistent identity of a pair of values.</summary>
	private class IdentityEqualityComparer : System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> {
		internal static readonly System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> Default = new IdentityEqualityComparer();

		private IdentityEqualityComparer() {
		}

		public bool Equals(<#= templateType.TypeName #> x, <#= templateType.TypeName #> y) {
			return x.Identity == y.Identity;
		}

		public int GetHashCode(<#= templateType.TypeName #> obj) {
			return obj.Identity.GetHashCode();
		}
	}

	private class ValueEqualityComparer : System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> {
		internal static readonly System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> Shallow = new ValueEqualityComparer(false);

		internal static readonly System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> Deep = new ValueEqualityComparer(true);

		private bool includeRecursiveChildren;

		private ValueEqualityComparer(bool includeRecursiveChildren) {
			this.includeRecursiveChildren = includeRecursiveChildren;
		}

		public bool Equals(<#= templateType.TypeName #> x, <#= templateType.TypeName #> y) {
			if (x == null && y == null) {
				return true;
			}

			if (x == null ^ y == null) {
				return false;
			}

			if (this.includeRecursiveChildren) {
				throw new System.NotImplementedException();
			}

			return x.DiffProperties(y) == <#= enumTypeName #>.None;
		}

		public int GetHashCode(<#= templateType.TypeName #> obj) {
			return obj.Identity.GetHashCode();
		}
	}
}

public System.Collections.Generic.IReadOnlyList<<#= diffTypeName #>> ChangesSince(<#= templateType.TypeName #> priorVersion) {
	return this.ChangesSince(priorVersion, positionUnderParentChanged: false);
}
<# if (!templateType.IsRecursiveParent) { #>

protected internal virtual System.Collections.Generic.IReadOnlyList<<#= diffTypeName #>> ChangesSince(<#= templateType.TypeName #> priorVersion, bool positionUnderParentChanged) {
	if (priorVersion == null) {
		throw new System.ArgumentNullException("priorVersion");
	}

	if (priorVersion.Identity != this.Identity) {
		throw new System.ArgumentException("Not another version of the same node.", "priorVersion");
	}

	var history = new System.Collections.Generic.List<<#= diffTypeName #>>();
	var changes = this.DiffProperties(priorVersion);
	if (changes != <#= enumTypeName #>.None) {
		history.Add(<#= diffTypeName #>.Change(priorVersion, this, changes));
	}

	return history;
}
<# } #>

protected virtual <#= enumTypeName #> DiffProperties(<#= templateType.TypeName #> other) {
	if (other == null) {
		throw new System.ArgumentNullException("other");
	}

	var propertiesChanged = <#= enumTypeName #>.None;

	if (!this.GetType().IsEquivalentTo(other.GetType())) {
		propertiesChanged |= <#= enumTypeName #>.Type;
	}
<#
	var additionalFields = templateType.LocalFields.Where(f => !f.IsRecursiveCollection);
	foreach (var field in additionalFields) {
#>

	if (this.<#= field.NamePascalCase #> != other.<#= field.NamePascalCase #>) {
		propertiesChanged |= <#= enumTypeName #>.<#= field.NamePascalCase #>;
	}
<#
	}
#>

	return propertiesChanged;
}
<#
				break;
			case HandleTypePosition.AfterTypeDeclaration:
#>

[System.Flags]
public enum <#= enumTypeName #> {
	/// <summary>
	/// No change was made to the node.  It was either entirely added or removed. 
	/// </summary>
	None = 0x0,

	/// <summary>
	/// The type of the node was changed.
	/// </summary>
	Type = 0x1,

	/// <summary>
	/// The node's position within its parent's list of children changed.
	/// </summary>
	PositionUnderParent = 0x2,
	
	/// <summary>
	/// The node was removed and reappeared in a new position in the tree (with a different parent).
	/// </summary>
	Parent = 0x4,
<#
				int counter = 3;
				// We're interested in enumerating the union of all fields on this and derived types,
				// excluding the recursive collection itself.
				var fields = templateType.Concat(templateType.Descendents)
					.SelectMany(t => t.LocalFields)
					.Where(f => !f.IsRecursiveCollection);
				foreach (var field in fields) {
#>

	/// <summary>
	/// The <see cref="<#= field.DeclaringType.TypeName #>.<#= field.NamePascalCase #>" /> property was changed.
	/// </summary>
	<#= field.NamePascalCase #> = <#= string.Format("0x{0:x}", (int)Math.Pow(2, counter)) #>,
<#
					counter++;
				}
#>

	/// <summary>
	/// All flags in this enum.
	/// </summary>
	All = Type | PositionUnderParent | Parent<#
	foreach (var field in fields) {
		Write(" | ");
		Write(field.NamePascalCase);
	}
#>,
}
<#
				break;
			default:
				break;
		}
	} else if (templateType.IsDerivedFromRecursiveType) {
		MetaType recursiveType = templateType.RecursiveTypeFromFamily;
		string enumTypeName = GetPropertiesEnumTypeName(recursiveType);
		string diffTypeName = GetDiffGramTypeName(recursiveType);
		switch (position) {
			case HandleTypePosition.WithinTypeDeclaration:
				var additionalFields = templateType.LocalFields.Where(f => !f.IsRecursiveCollection);
				if (additionalFields.Any()) {
#>

protected override <#= enumTypeName #> DiffProperties(<#= recursiveType.TypeName #> other) {
	var propertiesChanged = base.DiffProperties(other);

	var other<#= templateType.TypeName #> = other as <#= templateType.TypeName #>;
	if (other<#= templateType.TypeName #> != null) {<#
	foreach (var field in additionalFields) {
#>

		if (this.<#= field.NamePascalCase #> != other<#= templateType.TypeName #>.<#= field.NamePascalCase #>) {
			propertiesChanged |= <#= enumTypeName #>.<#= field.NamePascalCase #>;
		}
<#
	}
#>
	}

	return propertiesChanged;
}
<#
				}

				break;
			default:
				break;
		} // switch
	} // if derived from recursive type

	if (templateType.IsRecursiveParent) {
		MetaType recursiveType = templateType.RecursiveTypeFromFamily;
		string enumTypeName = GetPropertiesEnumTypeName(recursiveType);
		string diffTypeName = GetDiffGramTypeName(recursiveType);
		switch (position) {
			case HandleTypePosition.WithinTypeDeclaration:
				string changesSinceKeyword = templateType.HasAncestor ? "override " : "virtual ";
#>

protected internal <#= changesSinceKeyword #>System.Collections.Generic.IReadOnlyList<<#= diffTypeName #>> ChangesSince(<#= recursiveType.TypeName #> priorVersion, bool positionUnderParentChanged) {
	if (priorVersion == null) {
		throw new System.ArgumentNullException("priorVersion");
	}

	if (this == priorVersion) {
		return System.Collections.Immutable.ImmutableList.Create<<#= diffTypeName #>>();
	}

	if (priorVersion.Identity != this.Identity) {
		throw new System.ArgumentException("Not another version of the same node.", "priorVersion");
	}

	var history = new System.Collections.Generic.List<<#= diffTypeName #>>();

	var added = new System.Collections.Generic.HashSet<<#= templateType.RecursiveType.TypeName #>>(Comparers.Identity);
	var removed = new System.Collections.Generic.HashSet<<#= templateType.RecursiveType.TypeName #>>(Comparers.Identity);

	var other = priorVersion as <#= templateType.TypeName #>;
	if (other != null) {
		foreach (var priorChild in other.<#= templateType.RecursiveField.NamePascalCase #>) {
			<#= templateType.RecursiveType.TypeName #> currentChild;
			if (this.TryFind(priorChild.<#= templateType.RequiredIdentityField.NamePascalCase #>, out currentChild)) {
				if (!object.ReferenceEquals(priorChild, currentChild)) {
					bool positionChanged = false;
					if (this.<#= templateType.RecursiveField.NamePascalCase #>.KeyComparer.Compare(currentChild, priorChild) != 0) {
						// Calculate where the node was, and where it would go in the old tree.
						int beforeIndex = other.<#= templateType.RecursiveField.NamePascalCase #>.IndexOf(priorChild);
						int afterIndex = ~other.<#= templateType.RecursiveField.NamePascalCase #>.IndexOf(currentChild);

						// If the indices are the same, the new one would come "just before" the old one.
						// If the new index is just 1 greater than the old index, the new one would come "just after" the old one.
						// In either of these cases, since the old one will be gone in the new tree, the position hasn't changed.
						positionChanged = afterIndex != beforeIndex && afterIndex != beforeIndex + 1;
					}

					// Some change has been made to this or its descendents.
					history.AddRange(currentChild.ChangesSince(priorChild, positionChanged));
				}
			} else {
				removed.Add(priorChild);
			}
		}

		foreach (var currentChild in this.<#= templateType.RecursiveField.NamePascalCase #>) {
			if (!other.Contains(currentChild.<#= templateType.RequiredIdentityField.NamePascalCase #>)) {
				added.Add(currentChild);
			}
		}
	}

	history.AddRange(removed.Select(remove => <#= diffTypeName #>.Remove(remove)));

	var localChanges = this.DiffProperties(priorVersion);
	if (positionUnderParentChanged) {
		localChanges |= <#= enumTypeName #>.PositionUnderParent;
	}

	if (localChanges != <#= enumTypeName #>.None) {
		history.Add(DiffGram.Change(priorVersion, this, localChanges));
	}

	history.AddRange(added.Select(add => <#= diffTypeName #>.Add(add)));

	return history;
}
<#
				break;
			default:
				break;
		} // switch
	} // if IsRecursiveParent
}; // green type event handler

this.HandleRedType += (templateType, position) => {
	MetaType recursiveType = templateType.RecursiveTypeFromFamily;
	string enumTypeName = GetPropertiesEnumTypeName(recursiveType.GreenType);
	string diffTypeName = GetDiffGramTypeName(recursiveType.GreenType);
	switch (position) {
		case HandleTypePosition.WithinTypeDeclaration:
#>

	public System.Collections.Generic.IReadOnlyList<<#= diffTypeName #>> ChangesSince(<#= templateType.TypeName #> priorVersion) {
		this.ThrowIfDefault();
		return this.greenNode.ChangesSince(priorVersion.<#= templateType.GreenType.TypeName #>);
	}
<#
			break;
		default:
			break;
	}
}; // red type event handler
#>

<#+
	private string GetPropertiesEnumTypeName(MetaType templateType) {
		return templateType.TypeName + "ChangedProperties";
	}

	private string GetDiffGramTypeName(MetaType templateType) {
		return templateType.TypeName + ".DiffGram";
	}
#>
