<#
this.HandleType += (templateType, position) => {
	if (templateType.IsRecursiveType) {
		string enumTypeName = GetPropertiesEnumTypeName(templateType);
		string diffTypeName = GetDiffGramTypeName(templateType);
		switch (position) {
			case HandleTypePosition.WithinTypeDeclaration:
#>

/// <summary>
/// A description of a change made to an instance of an immutable object.
/// </summary>
public struct DiffGram {
	private DiffGram(<#= templateType.TypeName #> before, <#= templateType.TypeName #> after, ChangeKind kind, <#= enumTypeName #> changes)
		: this() {
		this.Before = before;
		this.After = after;
		this.Kind = kind;
		this.Changes = changes;
	}

	public static DiffGram Change(<#= templateType.TypeName #> before, <#= templateType.TypeName #> after, <#= enumTypeName #> changes) {
		return new DiffGram(before, after, ChangeKind.Replaced, changes);
	}

	public static DiffGram Add(<#= templateType.TypeName #> value) {
		return new DiffGram(null, value, ChangeKind.Added, default(<#= enumTypeName #>));
	}

	public static DiffGram Remove(<#= templateType.TypeName #> value) {
		return new DiffGram(value, null, ChangeKind.Removed, default(<#= enumTypeName #>));
	}

	/// <summary>
	/// Gets the leaf node before the change.
	/// </summary>
	public <#= templateType.TypeName #> Before { get; private set; }

	/// <summary>
	/// Gets the leaf node after the change.
	/// </summary>
	public <#= templateType.TypeName #> After { get; private set; }

	/// <summary>
	/// Gets the kind of change made to the alterered node.
	/// </summary>
	public ChangeKind Kind { get; private set; }

	/// <summary>
	/// Gets the kinds of changes made to node if <see cref="Kind"/> is <see cref="ChangeKind.Replaced"/>.
	/// </summary>
	public <#= enumTypeName #> Changes { get; private set; }

	/// <summary>
	/// Gets the identity of the affected object.
	/// </summary>
	public <#= templateType.RequiredIdentityField.TypeName #> Identity {
		get { return (this.Before ?? this.After).Identity; }
	}
}

public static class Comparers {
	/// <summary>Gets an equatable comparer that considers only the persistent identity of a pair of values.</summary>
	public static System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> Identity {
		get { return IdentityEqualityComparer.Default; }
	}

	/// <summary>Gets an equatable comparer that compares all properties between two instances.</summary>
	public static System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> ByValue {
		get { return ValueEqualityComparer.Shallow; }
	}

	/// <summary>Gets an equatable comparer that considers all properties between two instances and their children.</summary>
	public static System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> ByValueWithDescendents {
		get { return ValueEqualityComparer.Deep; }
	}

	/// <summary>An equatable and sorting comparer that considers only the persistent identity of a pair of values.</summary>
	private class IdentityEqualityComparer : System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> {
		internal static readonly System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> Default = new IdentityEqualityComparer();

		private IdentityEqualityComparer() {
		}

		public bool Equals(<#= templateType.TypeName #> x, <#= templateType.TypeName #> y) {
			return x.Identity == y.Identity;
		}

		public int GetHashCode(<#= templateType.TypeName #> obj) {
			return obj.Identity.GetHashCode();
		}
	}

	private class ValueEqualityComparer : System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> {
		internal static readonly System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> Shallow = new ValueEqualityComparer(false);

		internal static readonly System.Collections.Generic.IEqualityComparer<<#= templateType.TypeName #>> Deep = new ValueEqualityComparer(true);

		private bool includeRecursiveChildren;

		private ValueEqualityComparer(bool includeRecursiveChildren) {
			this.includeRecursiveChildren = includeRecursiveChildren;
		}

		public bool Equals(<#= templateType.TypeName #> x, <#= templateType.TypeName #> y) {
			if (x == null && y == null) {
				return true;
			}

			if (x == null ^ y == null) {
				return false;
			}

			if (this.includeRecursiveChildren) {
				throw new System.NotImplementedException();
			}

			return x.DiffProperties(y) == <#= enumTypeName #>.None;
		}

		public int GetHashCode(<#= templateType.TypeName #> obj) {
			return obj.Identity.GetHashCode();
		}
	}
}

public virtual System.Collections.Generic.IReadOnlyList<<#= diffTypeName #>> ChangesSince(<#= templateType.TypeName #> priorVersion) {
	if (priorVersion == null) {
		throw new System.ArgumentNullException("priorVersion");
	}

	if (priorVersion.Identity != this.Identity) {
		throw new System.ArgumentException("Not another version of the same node.", "priorVersion");
	}

	var history = new System.Collections.Generic.List<<#= diffTypeName #>>();
	var changes = this.DiffProperties(priorVersion);
	if (changes != <#= enumTypeName #>.None) {
		history.Add(<#= diffTypeName #>.Change(priorVersion, this, changes));
	}

	return history;
}

protected virtual <#= enumTypeName #> DiffProperties(<#= templateType.TypeName #> other) {
	if (other == null) {
		throw new System.ArgumentNullException("other");
	}

	var propertiesChanged = <#= enumTypeName #>.None;

	if (!this.GetType().IsEquivalentTo(other.GetType())) {
		propertiesChanged |= <#= enumTypeName #>.Type;
	}
<#
	var additionalFields = templateType.LocalFields.Where(f => !f.IsRecursiveCollection);
	foreach (var field in additionalFields) {
#>

	if (this.<#= field.NamePascalCase #> != other.<#= field.NamePascalCase #>) {
		propertiesChanged |= <#= enumTypeName #>.<#= field.NamePascalCase #>;
	}
<#
	}
#>

	return propertiesChanged;
}
<#
				break;
			case HandleTypePosition.AfterTypeDeclaration:
#>

[System.Flags]
public enum <#= enumTypeName #> {
	/// <summary>
	/// No change was made to the node.  It was either entirely added or removed. 
	/// </summary>
	None = 0x0,

	/// <summary>
	/// The type of the node was changed.
	/// </summary>
	Type = 0x1,

	/// <summary>
	/// The node's position within its parent's list of children changed.
	/// </summary>
	PositionUnderParent = 0x2,
<#
				int counter = 2;
				// We're interested in enumerating the union of all fields on this and derived types,
				// excluding the recursive collection itself.
				var fields = templateType.Concat(templateType.Descendents)
					.SelectMany(t => t.LocalFields)
					.Where(f => !f.IsRecursiveCollection);
				foreach (var field in fields) {
#>

	/// <summary>
	/// The <see cref="<#= field.DeclaringType.TypeName #>.<#= field.NamePascalCase #>" /> property was changed.
	/// </summary>
	<#= field.NamePascalCase #> = <#= string.Format("0x{0:x}", (int)Math.Pow(2, counter)) #>,
<#
					counter++;
				}
#>

	/// <summary>
	/// All flags in this enum.
	/// </summary>
	All = Type | PositionUnderParent<#
	foreach (var field in fields) {
		Write(" | ");
		Write(field.NamePascalCase);
	}
#>,
}
<#
				break;
			default:
				break;
		}
	} else if (templateType.IsDerivedFromRecursiveType) {
		MetaType recursiveType = templateType.RecursiveTypeFromFamily;
		string enumTypeName = GetPropertiesEnumTypeName(recursiveType);
		string diffTypeName = GetDiffGramTypeName(recursiveType);
		switch (position) {
			case HandleTypePosition.WithinTypeDeclaration:
				var additionalFields = templateType.LocalFields.Where(f => !f.IsRecursiveCollection);
				if (additionalFields.Any()) {
#>

protected override <#= enumTypeName #> DiffProperties(<#= recursiveType.TypeName #> other) {
	var propertiesChanged = base.DiffProperties(other);

	var other<#= templateType.TypeName #> = other as <#= templateType.TypeName #>;
	if (other<#= templateType.TypeName #> != null) {<#
	foreach (var field in additionalFields) {
#>

		if (this.<#= field.NamePascalCase #> != other<#= templateType.TypeName #>.<#= field.NamePascalCase #>) {
			propertiesChanged |= <#= enumTypeName #>.<#= field.NamePascalCase #>;
		}
<#
	}
#>
	}

	return propertiesChanged;
}
<#
				}

				if (templateType.Equals(templateType.RecursiveParent)) {
#>

public override System.Collections.Generic.IReadOnlyList<<#= diffTypeName #>> ChangesSince(<#= recursiveType.TypeName #> priorVersion) {
	if (priorVersion == null) {
		throw new System.ArgumentNullException("priorVersion");
	}

	if (this == priorVersion) {
		return System.Collections.Immutable.ImmutableList.Create<<#= diffTypeName #>>();
	}

	if (priorVersion.Identity != this.Identity) {
		throw new System.ArgumentException("Not another version of the same node.", "priorVersion");
	}

	var history = new System.Collections.Generic.List<<#= diffTypeName #>>();

	var other = (<#= templateType.TypeName #>) priorVersion;

	var added = this.<#= templateType.RecursiveField.NamePascalCase #>.Except(other.<#= templateType.RecursiveField.NamePascalCase #>);
	var removed = other.<#= templateType.RecursiveField.NamePascalCase #>.Except(this.<#= templateType.RecursiveField.NamePascalCase #>);
	var common = from child in this.<#= templateType.RecursiveField.NamePascalCase #>.Intersect(other.<#= templateType.RecursiveField.NamePascalCase #>)
	             select new { Prior = other.Find(child.Identity), Current = this.Find(child.Identity) };

	history.AddRange(removed.Select(remove => <#= diffTypeName #>.Remove(remove)));
	history.AddRange(base.ChangesSince(other));
	history.AddRange(common.SelectMany(change => change.Current.ChangesSince(change.Prior)));
	history.AddRange(added.Select(add => <#= diffTypeName #>.Add(add)));

	return history;
}
<#
				}

				break;
			default:
				break;
		} // switch
	} // if derived from recursive type
}; // green type event handler

this.HandleRedType += (templateType, position) => {
	MetaType recursiveType = templateType.RecursiveTypeFromFamily;
	string enumTypeName = GetPropertiesEnumTypeName(recursiveType.GreenType);
	string diffTypeName = GetDiffGramTypeName(recursiveType.GreenType);
	switch (position) {
		case HandleTypePosition.WithinTypeDeclaration:
#>

	public System.Collections.Generic.IReadOnlyList<<#= diffTypeName #>> ChangesSince(<#= templateType.TypeName #> priorVersion) {
		this.ThrowIfDefault();
		return this.greenNode.ChangesSince(priorVersion.<#= templateType.GreenType.TypeName #>);
	}
<#
			break;
		default:
			break;
	}
}; // red type event handler
#>

<#+
	private string GetPropertiesEnumTypeName(MetaType templateType) {
		return templateType.TypeName + "ChangedProperties";
	}

	private string GetDiffGramTypeName(MetaType templateType) {
		return templateType.TypeName + ".DiffGram";
	}
#>
