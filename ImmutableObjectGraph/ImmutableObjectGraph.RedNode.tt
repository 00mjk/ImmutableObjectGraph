<#
HiddenTypes.Add(typeof(RedMetaType));
this.HandleType += (templateType, position) => {
	var redType = new RedMetaType(templateType);

	switch (position) {
		case HandleTypePosition.WithinTypeDeclaration:
			if (redType.RecursiveParent.Equals(redType)) {
#>

public <#= redType.TypeName #> AsRoot {
	get { return new <#= redType.TypeName #>(this, this); }
}
<#
			}
#>

public <#= redType.TypeName #> WithRoot(<#= ((RedMetaType)redType.RecursiveParent).GreenType.TypeName #> root) {
	// TODO: add runtime check to ensure that in fact this node is a descendent of 'root'
	return new <#= redType.TypeName #>(this, root);
}
<#
			break;
		case HandleTypePosition.AfterTypeDeclaration:
			this.OnHandleRedType(redType, HandleTypePosition.BeforeTypeDeclaration);
#>

public partial struct <#= redType.TypeName #> {
	private readonly <#= redType.GreenType.TypeName #> greenNode;

	private readonly <#= ((RedMetaType)redType.RecursiveParent).GreenType.TypeName #> root;

	internal <#= redType.TypeName #>(<#= redType.GreenType.TypeName #> <#= redType.GreenType.TypeNameCamelCase #>, <#= ((RedMetaType)redType.RecursiveParent).GreenType.TypeName #> root) {
		this.greenNode = <#= redType.GreenType.TypeNameCamelCase #>;
		this.root = root;
	}

	/// <summary>Gets the parent.</summary>
	public <#= redType.RecursiveParent.TypeName #> Parent {
		get { throw new System.NotImplementedException(); }
	}

	public <#= redType.RecursiveParent.TypeName #> Root {
		get { return this.root.AsRoot; }
	}
<#
			if (redType.RecursiveParent.Equals(redType)) {
#>

	public bool IsRoot {
		get { return this.root == this.greenNode; }
	}
<#
			}

			foreach (var field in redType.AllFields) {
#>

	public <#= field.TypeName #> <#= field.NamePascalCase #> {
		get { return this.greenNode.<#= field.NamePascalCase #>; }
	}
<#
			}

			foreach (var field in redType.AllFields) {
				this.OnHandleRedField(redType, field);
			}
#>

	/// <summary>Gets the parent of this object in the hierarchy.</summary>
	public <#= redType.GreenType.TypeName #> <#= redType.GreenType.TypeName #> {
		get { return this.greenNode; }
	}
<#
			if (redType.IsRecursive) {
#>

	public System.Collections.Generic.IEnumerator<<#=redType.RecursiveType.TypeName#>> GetEnumerator() {
		return this.<#=redType.RecursiveField.NamePascalCase#>.GetEnumerator();
	}

	System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
		return this.<#=redType.RecursiveField.NamePascalCase#>.GetEnumerator();
	}
<#
			} // if IsRecursive

			this.OnHandleRedType(redType, HandleTypePosition.WithinTypeDeclaration);
#>
}
<#
			this.OnHandleRedType(redType, HandleTypePosition.AfterTypeDeclaration);
			break;
		default:
			break;
	} // switch
}; // event handler
#><#+
[DebuggerDisplay("{TypeName,nq} (red)")]
protected class RedMetaType : MetaType {
	public RedMetaType(MetaType greenType)
		: base(greenType.Type) {
		this.GreenType = greenType;
	}

	public MetaType GreenType { get; private set; }

	public override string TypeName {
		get { return "Rooted" + base.TypeName; }
	}

	public override MetaType RecursiveType {
		get { return Wrap(base.RecursiveType); }
	}

	public override IEnumerable<MetaType> Ancestors {
		get { return Wrap(base.Ancestors); }
	}
	
	public override MetaType Ancestor {
		get { return Wrap(base.Ancestor); }
	}

	public override IEnumerable<MetaType> Descendents {
		get { return Wrap(base.Descendents); }
	}

	public override bool Equals(object value) {
		var other = value as RedMetaType;
		return other != null && this.GreenType.Equals(other.GreenType);
	}

	private static RedMetaType Wrap(MetaType type) {
		return type != null ? new RedMetaType(type) : null;
	}

	private static IEnumerable<MetaType> Wrap(IEnumerable<MetaType> type) {
		return type.Select(t => new RedMetaType(t));
	}
	
	protected override MetaField CreateField(FieldInfo field) {
		return new RedMetaField(field, this);
	}

	protected override string GetTypeNameCore(Type type, bool isTemplateType) {
		return isTemplateType ? "Rooted" + type.Name : type.FullName;
	}

	[DebuggerDisplay("{DeclaringType.TypeName,nq}.{NamePascalCase,nq} (red)")]
	public class RedMetaField : MetaField {
		public RedMetaField(FieldInfo field, MetaType declaringType)
			: base(field, declaringType) {
		}
	}
}
#>
