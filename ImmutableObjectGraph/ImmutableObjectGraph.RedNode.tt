<#
HiddenTypes.Add(typeof(RedMetaType));
this.HandleType += (templateType, position) => {
	var redType = new RedMetaType(templateType);

	switch (position) {
		case HandleTypePosition.WithinTypeDeclaration:
			if (redType.RecursiveParent.Equals(redType)) {
#>

public <#= redType.TypeName #> AsRoot {
	get { return new <#= redType.TypeName #>(this, this); }
}
<#
			}
#>

public <#= redType.TypeName #> WithRoot(<#= ((RedMetaType)redType.RecursiveParent).GreenType.TypeName #> root) {
	// TODO: add runtime check to ensure that in fact this node is a descendent of 'root'
	return new <#= redType.TypeName #>(this, root);
}
<#
			break;
		case HandleTypePosition.AfterTypeDeclaration:
			this.OnHandleRedType(redType, HandleTypePosition.BeforeTypeDeclaration);
#>

public partial struct <#= redType.TypeName #> : System.IEquatable<<#= redType.TypeName #>> {
<#
			if (redType.Equals(redType.RecursiveParent)) {
#>
	private static readonly System.Func<<#=redType.RecursiveType.TypeName#>, <#=redType.GreenType.RecursiveType.TypeName#>> toUnrooted = r => r.<#=redType.GreenType.RecursiveType.TypeName#>;
	private static readonly System.Func<<#=redType.GreenType.RecursiveType.TypeName#>, <#=redType.GreenType.RecursiveParent.TypeName#>, <#=redType.RecursiveType.TypeName#>> toRooted = (u, r) => u.WithRoot(r);

<#
			}
#>
	private readonly <#= redType.GreenType.TypeName #> greenNode;

	private readonly <#= redType.GreenType.RecursiveParent.TypeName #> root;
<#
			if (redType.IsRecursive) {
#>
	private Optional<Adapters.ImmutableSetRootAdapter<<#=redType.GreenType.RecursiveType.TypeName#>, <#=redType.RecursiveType.TypeName#>, <#=redType.GreenType.RecursiveParent.TypeName#>>> <#= redType.RecursiveField.NameCamelCase #>;
<#
			}
#>

	internal <#= redType.TypeName #>(<#= redType.GreenType.TypeName #> <#= redType.GreenType.TypeNameCamelCase #>, <#= redType.GreenType.RecursiveParent.TypeName #> root) {
		this.greenNode = <#= redType.GreenType.TypeNameCamelCase #>;
		this.root = root;
<#
			if (redType.IsRecursive) {
#>
		this.<#= redType.RecursiveField.NameCamelCase #> = default(Optional<Adapters.ImmutableSetRootAdapter<<#=redType.GreenType.RecursiveType.TypeName#>, <#=redType.RecursiveType.TypeName#>, <#=redType.GreenType.RecursiveParent.TypeName#>>>);
<#
			}
#>
	}

	/// <summary>Gets the parent of this object in the hierarchy.</summary>
	public <#= redType.RecursiveParent.TypeName #> Parent {
		get { throw new System.NotImplementedException(); }
	}

	public <#= redType.RecursiveParent.TypeName #> Root {
		get { return this.root.AsRoot; }
	}
<#
			foreach (var descendent in redType.Descendents) {
				var greenDescendent = ((RedMetaType)descendent).GreenType;
#>

	public bool Is<#=greenDescendent.TypeName#> {
		get { return this.greenNode is <#=greenDescendent.TypeName#>; }
	}

	public <#=descendent.TypeName#> As<#=greenDescendent.TypeName#> {
		get { return ((<#=greenDescendent.TypeName#>)this.greenNode).WithRoot(this.root); }
	}
<#
			}

			foreach (var ancestor in redType.Ancestors) {
				var greenAncestor = ((RedMetaType)ancestor).GreenType;
#>

	public <#=ancestor.TypeName#> As<#=greenAncestor.TypeName#> {
		get { return ((<#=greenAncestor.TypeName#>)this.greenNode).WithRoot(this.root); }
	}
<#
			}

			if (redType.RecursiveParent.Equals(redType)) {
#>

	public bool IsRoot {
		get { return this.root == this.greenNode; }
	}
<#
			}

			foreach (var field in redType.AllFields) {
				if (field.IsRecursiveCollection) {
#>

	public System.Collections.Immutable.IImmutableSet<<#= field.ElementTypeName #>> <#= field.NamePascalCase #> {
		get {
			if (!this.<#= field.NameCamelCase #>.IsDefined) {
				this.<#= field.NameCamelCase #> = Optional.For(Adapter.Create(this.greenNode.<#= field.NamePascalCase #>, toRooted, toUnrooted, this.root));
			}

			return this.<#= field.NameCamelCase #>.Value;
		}
	}
<#
				} else {
#>

	public <#= field.TypeName #> <#= field.NamePascalCase #> {
		get { return this.greenNode.<#= field.NamePascalCase #>; }
	}
<#
				}

				this.OnHandleRedField(redType, field);
			}
#>

	/// <summary>Gets the unrooted representation of this object in the hierarchy.</summary>
	public <#= redType.GreenType.TypeName #> <#= redType.GreenType.TypeName #> {
		get { return this.greenNode; }
	}
<#
			if (redType.IsRecursive) {
#>

	public System.Collections.Generic.IEnumerator<<#=redType.RecursiveType.TypeName#>> GetEnumerator() {
		return this.<#=redType.RecursiveField.NamePascalCase#>.GetEnumerator();
	}
<#
			} // if IsRecursive

			this.OnHandleRedType(redType, HandleTypePosition.WithinTypeDeclaration);
#>

	public override bool Equals(object obj) {
		if (obj is <#= redType.TypeName #>) {
			var other = (<#= redType.TypeName #>)obj;
			return this.Equals(other);
		}

		return false;
	}

	public bool Equals(<#= redType.TypeName #> other) {
		return this.greenNode == other.greenNode && this.root == other.root;
	}

	public override int GetHashCode() {
		return this.greenNode.GetHashCode();
	}

	private <#= redType.TypeName #> NewSpine(<#= redType.GreenType.TypeName #> leaf) {
		// TODO: spine rewrite here.
		return leaf.WithRoot(this.root);
	}
}
<#
			this.OnHandleRedType(redType, HandleTypePosition.AfterTypeDeclaration);
			break;
		default:
			break;
	} // switch
}; // event handler
#><#+
[DebuggerDisplay("{TypeName,nq} (red)")]
protected class RedMetaType : MetaType {
	public RedMetaType(MetaType greenType)
		: base(greenType.Type) {
		if (greenType is RedMetaType) {
			throw new ArgumentException("Red type handed in as green type.");
		}

		this.GreenType = greenType;
	}

	public MetaType GreenType { get; private set; }

	public override string TypeName {
		get { return "Rooted" + base.TypeName; }
	}

	public override MetaType RecursiveType {
		get { return Wrap(base.RecursiveType); }
	}

	public override IEnumerable<MetaType> Ancestors {
		get { return Wrap(base.Ancestors); }
	}
	
	public override MetaType Ancestor {
		get { return Wrap(base.Ancestor); }
	}

	public override IEnumerable<MetaType> Descendents {
		get { return Wrap(base.Descendents); }
	}

	public override bool Equals(object value) {
		var other = value as RedMetaType;
		return other != null && this.GreenType.Equals(other.GreenType);
	}

	private static RedMetaType Wrap(MetaType type) {
		return type != null ? new RedMetaType(type) : null;
	}

	private static IEnumerable<MetaType> Wrap(IEnumerable<MetaType> type) {
		return type.Select(t => t is RedMetaType ? t : new RedMetaType(t));
	}
	
	protected override MetaField CreateField(FieldInfo field) {
		return new RedMetaField(field, this);
	}

	protected override string GetTypeNameCore(Type type, bool isTemplateType) {
		return isTemplateType ? "Rooted" + type.Name : type.FullName;
	}

	[DebuggerDisplay("{DeclaringType.TypeName,nq}.{NamePascalCase,nq} (red)")]
	public class RedMetaField : MetaField {
		public RedMetaField(FieldInfo field, MetaType declaringType)
			: base(field, declaringType) {
		}
	}
}
#>
