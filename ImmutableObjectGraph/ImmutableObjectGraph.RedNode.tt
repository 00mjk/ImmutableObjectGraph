<#
HiddenTypes.Add(typeof(RedMetaType));

this.HandleType += (templateType, position) => {
	if (position != HandleTypePosition.AfterTypeDeclaration) {
		return;
	}

	var redType = new RedMetaType(templateType);
	this.OnHandleRedType(redType, HandleTypePosition.BeforeTypeDeclaration);
#>

public <#= redType.IsAbstract ? "abstract " : "" #>partial class <#= redType.TypeName #><# WriteBaseTypes(redType.HasAncestor ? redType.Ancestor.TypeName : null, redType.IsRecursive ? "System.Collections.Generic.IEnumerable<" + redType.RecursiveType.TypeName + ">" : null); #> {
<#	if (!redType.HasAncestor) { #>
	private readonly <#= redType.GreenType.TypeName #> greenNode;

	private readonly <#= redType.RecursiveParent.TypeName #> parent;
<#	}

	foreach (var field in redType.LocalFields.Where(f => !f.IsPrimitiveType)) {
#>
	private <#= field.TypeName #> <#= field.NameCamelCase #>;
<#
		}
#>

	protected <#= redType.TypeName #>(<#= redType.GreenType.TypeName #> greenNode, <#= redType.RecursiveParent.TypeName #> parent) <# if (redType.HasAncestor) { #>: base(greenNode, parent) <# } #>{
<# if (!redType.HasAncestor) { #>
		this.greenNode = greenNode;
		this.parent = parent;
<# } #>
	}
<# if (!redType.HasAncestor) { #>

	/// <summary>Gets the parent.</summary>
	public <#= redType.RecursiveParent.TypeName #> Parent {
		get { return this.parent; }
	}
<#
	}

	foreach (var field in redType.LocalFields) {
#>

	public <#= field.TypeName #> <#= field.NamePascalCase #> {
<#	if (field.IsPrimitiveType) { #>
		get { return this.GreenNode.<#= field.NamePascalCase #>; }
<# } else { #>
		get { return this.<#= field.NameCamelCase #>; }
<# } #>
	}
<#
	}

	foreach (var field in redType.AllFields) {
		this.OnHandleRedField(redType, field);
	}
#>

	/// <summary>Gets the parent of this object in the hierarchy.</summary>
	protected <# if (redType.HasAncestor) { #>new <# } #><#= redType.GreenType.TypeName #> GreenNode {
		get { return <# if (redType.HasAncestor) { #>(<#= redType.GreenType.TypeName #>)base.GreenNode<# } else { #>this.greenNode<# } #>; }
	}
<#	if (redType.IsRecursive) { #>

	public System.Collections.Generic.IEnumerator<<#=redType.RecursiveType.TypeName#>> GetEnumerator() {
		return this.<#=redType.RecursiveField.NamePascalCase#>.GetEnumerator();
	}

	System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
		return this.<#=redType.RecursiveField.NamePascalCase#>.GetEnumerator();
	}
<#
	} // if IsRecursive

	this.OnHandleRedType(redType, HandleTypePosition.WithinTypeDeclaration);
#>
}
<#
	this.OnHandleRedType(redType, HandleTypePosition.AfterTypeDeclaration);
}; // event handler
#><#+
[DebuggerDisplay("{TypeName,nq} (red)")]
protected class RedMetaType : MetaType {
	public RedMetaType(MetaType greenType)
		: base(greenType.Type) {
		this.GreenType = greenType;
	}

	public MetaType GreenType { get; private set; }

	public override string TypeName {
		get { return base.TypeName + "Red"; }
	}

	public override MetaType RecursiveType {
		get { return Wrap(base.RecursiveType); }
	}

	public override IEnumerable<MetaType> Ancestors {
		get { return Wrap(base.Ancestors); }
	}
	
	public override MetaType Ancestor {
		get { return Wrap(base.Ancestor); }
	}

	public override IEnumerable<MetaType> Descendents {
		get { return Wrap(base.Descendents); }
	}

	public override bool Equals(object value) {
		var other = value as RedMetaType;
		return other != null && this.GreenType.Equals(other.GreenType);
	}

	private static RedMetaType Wrap(MetaType type) {
		return type != null ? new RedMetaType(type) : null;
	}

	private static IEnumerable<MetaType> Wrap(IEnumerable<MetaType> type) {
		return type.Select(t => new RedMetaType(t));
	}
	
	protected override MetaField CreateField(FieldInfo field) {
		return new RedMetaField(field, this);
	}

	protected override string GetTypeNameCore(Type type, bool isTemplateType) {
		return isTemplateType ? type.Name + "Red" : type.FullName;
	}

	[DebuggerDisplay("{DeclaringType.TypeName,nq}.{NamePascalCase,nq} (red)")]
	public class RedMetaField : MetaField {
		public RedMetaField(FieldInfo field, MetaType declaringType)
			: base(field, declaringType) {
		}
	}
}
#>
