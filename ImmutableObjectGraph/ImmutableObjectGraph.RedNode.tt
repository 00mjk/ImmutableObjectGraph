<#
HiddenTypes.Add(typeof(RedMetaType));
this.HandleType += (templateType, position) => {
	var redType = new RedMetaType(templateType);

	switch (position) {
		case HandleTypePosition.WithinTypeDeclaration:
			if (redType.RecursiveParent.Equals(redType)) {
#>

public <#= redType.TypeName #> AsRoot {
	get { return new <#= redType.TypeName #>(this, this); }
}
<#
			}
#>

public <#= redType.HasAncestor ? "new " : "" #><#= redType.TypeName #> WithRoot(<#= redType.GreenType.RecursiveParent.TypeName #> root) {
	var spine = root.GetSpine(this);
	if (spine.IsEmpty) {
		throw new System.ArgumentException("Root does not belong to the same tree.");
	}

	return new <#= redType.TypeName #>(this, root);
}
<#
			break;
		case HandleTypePosition.AfterTypeDeclaration:
			this.OnHandleRedType(redType, HandleTypePosition.BeforeTypeDeclaration);
#>

public partial struct <#= redType.TypeName #> : System.IEquatable<<#= redType.TypeName #>> {
<#
			if (redType.Equals(redType.RecursiveParent)) {
#>
	private static readonly System.Func<<#=redType.RecursiveType.TypeName#>, <#=redType.GreenType.RecursiveType.TypeName#>> toUnrooted = r => r.<#=redType.GreenType.RecursiveType.TypeName#>;
	private static readonly System.Func<<#=redType.GreenType.RecursiveType.TypeName#>, <#=redType.GreenType.RecursiveParent.TypeName#>, <#=redType.RecursiveType.TypeName#>> toRooted = (u, r) => u.WithRoot(r);

<#
			}
#>
	private readonly <#= redType.GreenType.TypeName #> greenNode;

	private readonly <#= redType.GreenType.RecursiveParent.TypeName #> root;
<#
			if (redType.IsRecursive) {
#>
	private Optional<Adapters.ImmutableSetRootAdapter<<#=redType.GreenType.RecursiveType.TypeName#>, <#=redType.RecursiveType.TypeName#>, <#=redType.GreenType.RecursiveParent.TypeName#>>> <#= redType.RecursiveField.NameCamelCase #>;
<#
			}
#>

	internal <#= redType.TypeName #>(<#= redType.GreenType.TypeName #> <#= redType.GreenType.TypeNameCamelCase #>, <#= redType.GreenType.RecursiveParent.TypeName #> root) {
		this.greenNode = <#= redType.GreenType.TypeNameCamelCase #>;
		this.root = root;
<#
			if (redType.IsRecursive) {
#>
		this.<#= redType.RecursiveField.NameCamelCase #> = default(Optional<Adapters.ImmutableSetRootAdapter<<#=redType.GreenType.RecursiveType.TypeName#>, <#=redType.RecursiveType.TypeName#>, <#=redType.GreenType.RecursiveParent.TypeName#>>>);
<#
			}
#>
	}

	/// <summary>Gets the parent of this object in the hierarchy.</summary>
	public <#= redType.RecursiveParent.TypeName #> Parent {
		get { throw new System.NotImplementedException(); }
	}

	public <#= redType.RecursiveParent.TypeName #> Root {
		get { return this.root != null ? this.root.AsRoot : default(<#= redType.RecursiveParent.TypeName #>); }
	}

	public <#= templateType.RequiredIdentityField.TypeName #> Identity {
		get {
			this.ThrowIfDefault();
			return this.greenNode.Identity;
		}
	}
<#
			foreach (var descendent in redType.Descendents) {
				var greenDescendent = ((RedMetaType)descendent).GreenType;
#>

	public bool Is<#=greenDescendent.TypeName#> {
		get { return this.greenNode is <#=greenDescendent.TypeName#>; }
	}

	public <#=descendent.TypeName#> As<#=greenDescendent.TypeName#> {
		get { return this.greenNode != null ? ((<#=greenDescendent.TypeName#>)this.greenNode).WithRoot(this.root) : default(<#=descendent.TypeName#>); }
	}
<#
			}

			foreach (var ancestor in redType.Ancestors) {
				var greenAncestor = ((RedMetaType)ancestor).GreenType;
#>

	public <#=ancestor.TypeName#> As<#=greenAncestor.TypeName#> {
		get { return this.greenNode != null ? ((<#=greenAncestor.TypeName#>)this.greenNode).WithRoot(this.root) : default(<#=ancestor.TypeName#>); }
	}
<#
			}

			if (redType.RecursiveParent.Equals(redType)) {
#>

	public bool IsRoot {
		get { return this.root == this.greenNode; }
	}
<#
			}

			foreach (var field in redType.AllFields) {
				if (field.IsRecursiveCollection) {
#>

	public System.Collections.Immutable.IImmutableSet<<#= field.ElementTypeName #>> <#= field.NamePascalCase #> {
		get {
			if (!this.<#= field.NameCamelCase #>.IsDefined) {
				this.ThrowIfDefault();
				this.<#= field.NameCamelCase #> = Optional.For(Adapter.Create(this.greenNode.<#= field.NamePascalCase #>, toRooted, toUnrooted, this.root));
			}

			return this.<#= field.NameCamelCase #>.Value;
		}
	}
<#
				} else {
#>

	public <#= field.TypeName #> <#= field.NamePascalCase #> {
		get {
			this.ThrowIfDefault();
			return this.greenNode.<#= field.NamePascalCase #>;
		}
	}
<#
				}

				this.OnHandleRedField(redType, field);
			}
#>

	/// <summary>Gets the unrooted representation of this object in the hierarchy.</summary>
	public <#= redType.GreenType.TypeName #> <#= redType.GreenType.TypeName #> {
		get { return this.greenNode; }
	}

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public <#= redType.TypeName #> With(<#
		WriteParameters(redType.AllFields, ParameterStyle.Optional);
#>) {
		this.ThrowIfDefault();
		var newGreenNode = this.greenNode.With(<# WriteArguments(redType.AllFields, ArgSource.Argument); #>);
		var newRoot = this.root.ReplaceDescendent(this.greenNode, newGreenNode);
		return newGreenNode.WithRoot(newRoot);
	}
<#
			if (redType.IsRecursive) {
#>

	public static <#= redType.TypeName #> Create(<# WriteParameters(redType.AllFields, ParameterStyle.OptionalOrRequired); #>) {
		var greenNode = <#= redType.GreenType.TypeName#>.Create(<# WriteArguments(redType.AllFields, ArgSource.Argument); #>);
		return greenNode.AsRoot;
	}

	public <#=redType.RecursiveType.TypeName#> Find(<#= templateType.RequiredIdentityField.TypeName #> identity) {
		var found = this.greenNode.Find(identity);
		return found != null ? found.WithRoot(this.root) : default(<#=redType.RecursiveType.TypeName#>);
	}

	public System.Collections.Generic.IEnumerator<<#=redType.RecursiveType.TypeName#>> GetEnumerator() {
		return this.<#=redType.RecursiveField.NamePascalCase#>.GetEnumerator();
	}
<#
			} // if IsRecursive

			this.OnHandleRedType(redType, HandleTypePosition.WithinTypeDeclaration);
#>

	public override bool Equals(object obj) {
		if (obj is <#= redType.TypeName #>) {
			var other = (<#= redType.TypeName #>)obj;
			return this.Equals(other);
		}

		return false;
	}

	public bool Equals(<#= redType.TypeName #> other) {
		return this.greenNode == other.greenNode && this.root == other.root;
	}

	public override int GetHashCode() {
		return this.greenNode == null ? 0 : this.greenNode.GetHashCode();
	}

	private <#= redType.TypeName #> NewSpine(<#= redType.GreenType.TypeName #> leaf) {
		var newRoot = this.root.ReplaceDescendent(this.greenNode, leaf);
		return leaf.WithRoot(newRoot);
	}

	/// <summary>Throws an exception if this struct does not have a backing <#= redType.GreenType.TypeName #>.</summary>
	private void ThrowIfDefault() {
		if (this.greenNode == null) {
			throw new System.InvalidOperationException();
		}
	}
}
<#
			this.OnHandleRedType(redType, HandleTypePosition.AfterTypeDeclaration);
			break;
		default:
			break;
	} // switch
}; // event handler
#><#+
[DebuggerDisplay("{TypeName,nq} (red)")]
protected class RedMetaType : MetaType {
	private readonly MetaType greenType;

	public RedMetaType(MetaType greenType)
		: base(greenType.Type) {
		if (greenType is RedMetaType) {
			throw new ArgumentException("Red type handed in as green type.");
		}

		this.greenType = greenType;
	}

	public override MetaType GreenType {
		get { return this.greenType; }
	}

	public override string TypeName {
		get { return "Rooted" + base.TypeName; }
	}

	public override MetaType RecursiveType {
		get { return Wrap(base.RecursiveType); }
	}

	public override IEnumerable<MetaType> Ancestors {
		get { return Wrap(base.Ancestors); }
	}
	
	public override MetaType Ancestor {
		get { return Wrap(base.Ancestor); }
	}

	public override IEnumerable<MetaType> Descendents {
		get { return Wrap(base.Descendents); }
	}

	public override bool Equals(object value) {
		var other = value as RedMetaType;
		return other != null && this.GreenType.Equals(other.GreenType);
	}

	public override int GetHashCode() {
		return this.GreenType.GetHashCode();
	}

	private static RedMetaType Wrap(MetaType type) {
		return type != null ? new RedMetaType(type) : null;
	}

	private static IEnumerable<MetaType> Wrap(IEnumerable<MetaType> type) {
		return type.Select(t => t is RedMetaType ? t : new RedMetaType(t));
	}
	
	protected override MetaField CreateField(FieldInfo field) {
		return new RedMetaField(field, this);
	}

	protected override string GetTypeNameCore(Type type, bool isTemplateType) {
		return isTemplateType ? "Rooted" + type.Name : type.FullName;
	}

	[DebuggerDisplay("{DeclaringType.TypeName,nq}.{NamePascalCase,nq} (red)")]
	public class RedMetaField : MetaField {
		public RedMetaField(FieldInfo field, MetaType declaringType)
			: base(field, declaringType) {
		}

		public override MetaField GreenField {
			get { return ((RedMetaType)this.DeclaringType).GreenType.LocalFields.Single(f => f.Field == this.Field); }
		}

		public override string TypeName {
			get {
				if (this.IsRecursiveCollection) {
					return string.Format("System.Collections.Immutable.IImmutableSet<{0}>", this.ElementTypeName);
				} else {
					return base.TypeName;
				}
			}
		}

		public override string ArgumentReference {
			get {
				if (this.IsRecursiveCollection) {
					return string.Format("{1}.IsDefined ? ({2})((Adapters.IImmutableCollectionAdapter<{0}>){1}.Value).UnderlyingCollection : default({3})", this.GreenField.ElementTypeName, this.NameCamelCase, this.GreenField.TypeName, this.GreenField.OptionalTypeName);
				} else {
					return base.ArgumentReference;
				}
			}
		}
	}
}
#>
