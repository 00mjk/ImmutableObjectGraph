<#
this.HandleType += (templateType, position) => {
	if (position != HandleTypePosition.WithinTypeDeclaration) {
		return;
	}

	if (templateType.IsRecursive) {
#>

public <#= templateType.TypeName #> ReplaceDescendent(<#= templateType.RecursiveType.TypeName #> current, <#= templateType.RecursiveType.TypeName #> replacement) {
	var spine = this.GetSpine(current);

	if (spine.IsEmpty) {
		// The descendent was not found.
		throw new System.ArgumentException("Old value not found");
	}

	return (<#= templateType.TypeName #>)this.ReplaceDescendent(spine, replacement);
}

private <#= templateType.RecursiveType.TypeName #> ReplaceDescendent(System.Collections.Immutable.ImmutableStack<<#= templateType.RecursiveType.TypeName #>> spine, <#= templateType.RecursiveType.TypeName #> replacement) {
	Debug.Assert(this == spine.Peek());
	var remainingSpine = spine.Pop();
	if (remainingSpine.IsEmpty) {
		// This is the instance to be replaced.
		return replacement;
	}

	<#= templateType.RecursiveType.TypeName #> newChild;
	var child = remainingSpine.Peek();
	var recursiveChild = child as <#= templateType.RecursiveParent.TypeName #>;
	if (recursiveChild != null) {
		newChild = recursiveChild.ReplaceDescendent(remainingSpine, replacement);
	} else {
		Debug.Assert(remainingSpine.Pop().IsEmpty); // we should be at the tail of the stack, since we're at a leaf.
		Debug.Assert(this.<#= templateType.RecursiveField.NamePascalCase #>.Contains(child));
		newChild = replacement;
	}

	var newChildren = this.<#= templateType.RecursiveField.NamePascalCase #>.Replace(child, newChild);
	return this.With<#= templateType.RecursiveField.NamePascalCase #>(newChildren);
}
<#
	}
}; // event handler
#>