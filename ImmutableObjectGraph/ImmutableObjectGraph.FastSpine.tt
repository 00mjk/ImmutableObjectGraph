<#
this.HandleType += (templateType, position) => {
	switch (position) {
		case HandleTypePosition.InsideConstructor:
			if (templateType.IsRecursive) {
#>
		this.InitializeLookup();
<#
			}
			
			break;

		case HandleTypePosition.WithinTypeDeclaration:
			if (templateType.RootAncestorOrThisType.Equals(templateType)) {
#>

private System.IntPtr identity;

protected internal System.IntPtr Identity {
	get { return this.identity; }
}
<#
			}

			if (templateType.IsRecursive) {
				var nodeLookupTableTypeName = string.Format("System.Collections.Immutable.ImmutableDictionary<System.IntPtr, System.Collections.Generic.KeyValuePair<{0}, System.IntPtr>>", templateType.RecursiveType.TypeName);
#>

private static readonly System.Collections.Immutable.ImmutableDictionary<System.IntPtr, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.IntPtr>> lookupTableLazySentinal = System.Collections.Immutable.ImmutableDictionary.Create<System.IntPtr, System.Collections.Generic.KeyValuePair<FileSystemEntry, System.IntPtr>>().Add(System.IntPtr.Zero, new System.Collections.Generic.KeyValuePair<FileSystemEntry, System.IntPtr>());

private <#= nodeLookupTableTypeName #> lookupTable;

private int inefficiencyLoad;

/// <summary>
/// The maximum number of steps allowable for a search to be done among this node's children
/// before a faster lookup table will be built.
/// </summary>
private const int InefficiencyLoadThreshold = 16;

private <#= nodeLookupTableTypeName #> LookupTable {
	get {
		if (this.lookupTable == lookupTableLazySentinal) {
			this.lookupTable = this.CreateLookupTable();
			this.inefficiencyLoad = 1;
		}

		return this.lookupTable;
	}
}

private void InitializeLookup() {
	this.inefficiencyLoad = 1;
	foreach (var child in this.<#= templateType.RecursiveField.NameCamelCase #>)
	{
		var recursiveChild = child as <#= templateType.RecursiveParent.TypeName #>;
		this.inefficiencyLoad += recursiveChild != null ? recursiveChild.inefficiencyLoad : 1;
	}

	if (this.inefficiencyLoad > InefficiencyLoadThreshold) {
		this.inefficiencyLoad = 1;
		this.lookupTable = lookupTableLazySentinal;
	}
}

/// <summary>
/// Creates the lookup table that will contain all this node's children.
/// </summary>
/// <returns>The lookup table.</returns>
private <#= nodeLookupTableTypeName #> CreateLookupTable() {
	var table = System.Collections.Immutable.ImmutableDictionary.Create<System.IntPtr, System.Collections.Generic.KeyValuePair<<#= templateType.RecursiveType.TypeName #>, System.IntPtr>>().ToBuilder();
	this.ContributeDescendentsToLookupTable(table);
	return table.ToImmutable();
}

/// <summary>
/// Adds this node's children (recursively) to the lookup table.
/// </summary>
/// <param name="seedLookupTable">The lookup table to add entries to.</param>
/// <returns>The new lookup table.</returns>
private void ContributeDescendentsToLookupTable(<#= nodeLookupTableTypeName #>.Builder seedLookupTable)
{
	foreach (var child in this.<#= templateType.RecursiveField.NamePascalCase #>)
	{
		seedLookupTable.Add(child.Identity, new System.Collections.Generic.KeyValuePair<<#= templateType.RecursiveType.TypeName #>, System.IntPtr>(child, this.Identity));
		var recursiveChild = child as <#= templateType.RecursiveParent.TypeName #>;
		if (recursiveChild != null) {
			recursiveChild.ContributeDescendentsToLookupTable(seedLookupTable);
		}
	}
}

internal System.Collections.Immutable.ImmutableStack<<#= templateType.RecursiveType.TypeName #>> GetSpine(System.IntPtr descendent) {
	var emptySpine = System.Collections.Immutable.ImmutableStack.Create<<#= templateType.RecursiveType.TypeName #>>();
	if (this.Identity.Equals(descendent)) {
		return emptySpine.Push(this);
	}

	if (this.LookupTable != null) {
		System.Collections.Generic.KeyValuePair<<#= templateType.RecursiveType.TypeName #>, System.IntPtr> lookupValue;
		if (this.LookupTable.TryGetValue(descendent, out lookupValue))
		{
			// Awesome.  We know the node the caller is looking for is a descendent of this node.
			// Now just string together all the nodes that connect this one with the sought one.
			var spine = emptySpine;
			do
			{
				spine = spine.Push(lookupValue.Key);
			}
			while (this.lookupTable.TryGetValue(lookupValue.Value, out lookupValue));
			return spine.Push(this);
		}
	} else {
		// We don't have an efficient lookup table for this node.  Aggressively search every child.
		var spine = emptySpine;
		foreach (var child in this.Children) {
			var recursiveChild = child as <#= templateType.RecursiveParent.TypeName #>;
			if (recursiveChild != null) {
				spine = recursiveChild.GetSpine(descendent);
			} else if (child.Identity.Equals(descendent)) {
				spine = spine.Push(child);
			}

			if (!spine.IsEmpty) {
				return spine.Push(this);
			}
		}
	}

	// The descendent is not in this sub-tree.
	return emptySpine;
}

internal System.Collections.Immutable.ImmutableStack<<#= templateType.RecursiveType.TypeName #>> GetSpine(<#= templateType.RecursiveType.TypeName #> descendent) {
	return this.GetSpine(descendent.Identity);
}
<#
			}

			break;
		default:
			break;
	}
}; // event handler
#>